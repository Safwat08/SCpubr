# Bar plots

Bar plots are another well known data representation. They are a very handy resource to plot summary statistics for the QC part of any single-cell analysis. Consequently, they are part of `SCpubr`, available on `SCpubr::do_BarPlot()`. Let's say we are interested into plotting the different number of cells in each cluster. 

```{r, fig.cap = "SCpubr Bar plots, plotting single variables", fig.width=12, fig.height=5}
p1 <- SCpubr::do_BarPlot(sample, feature = "seurat_clusters", legend = F, plot.title = "Number of cells per cluster")
p2 <- SCpubr::do_BarPlot(sample, feature = "seurat_clusters", legend = F, plot.title = "Number of cells per cluster", horizontal = F)
p1 | p2
```
Using `SCpubr::do_BarPlot()` with only `features` yields a simple bar plot which is ordered by descending value. We can also set up the direction of the bars with `horizontal = TRUE/FALSE`, which by default is set to be horizontal. There are some underlying assumptions that are being taken to generate these plots:
- The values in `features` need to be metadata variables, stored in `object@meta.data`. This a design choice, as data need to be grouped using `dplyr` and `tidyr`. This will also later apply to values provided to `group.by`.
- The feature provided need to have a clear and rather small number of groups. A good estimate on how to assess this is by querying the feature with `table`, as in:

```{r, eval = F}
table(sample@meta.data[, feature])
```


Focusing on the last point, this would happen if we were to choose a feature with a high number of unique values:

```{r, fig.cap = "SCpubr Bar plots, choosing the wrong variable", fig.width=12, fig.height=5}

p <- SCpubr::do_BarPlot(sample, feature = "nCount_RNA", legend = F, plot.title = "Number of UMIs?", horizontal = F)
p
```

This happens, precisely, because of the high amount of unique values for `nCount_RNA`. These type of continuous values is best suited for other data visualizations like a `histogram`.

## Introducing a second variable to group the feature by
Let's expand on the previous example on the number of cells per cluster. What if we were interested not only on that, but we would like to profile **how many cells from each cluster are present in each of the unique samples present in the Seurat object**? For this, we need to provide `SCpubr::do_BarPlot()` with a second parameter, `group.by`, that tackles how we want the feature to be grouped:

```{r, fig.cap = "SCpubr Bar plots, introducing a variable to group values by", fig.width=12, fig.height=5}
# We only have one value in orig.ident. Let's modify it so that it resembles a multi-sample Seurat object.
sample$modified_orig.ident <- sample(c("Sample_A", "Sample_B", "Sample_C"), ncol(sample), replace = T, prob = c(0.2, 0.7, 0.1))

p1 <- SCpubr::do_BarPlot(sample, 
                        feature = "modified_orig.ident",
                        plot.title = "Number of cells per sample",
                        position = "stack",
                        legend = T,
                        horizontal = F)

p2 <- SCpubr::do_BarPlot(sample, 
                        feature = "modified_orig.ident", 
                        group.by = "seurat_clusters",
                        plot.title = "Number of cells per cluster and sample",
                        position = "stack",
                        legend = T,
                        horizontal = F)
p1 | p2
```

As we can see, this nicely yields as many number of bars as unique values in the `feature`, and this bars are segmented by as many times as unique values in `group.by`. At first, this is hard to grasp, but it helps thinking of these two parameters, when used together, as:
- `feature`: What I want to show as different bars.
- `group.by`: Secondary variable on which the bars generated by `feature` can be further subdivided.

Another interesting parameter introduced in the last example is `position`. Position can be either `stack` or `fill`. The difference between them is that `position = "stack"` will yield the total number of cells for each of the unique values in `feature`, while `position = "fill"` will bring all bars to the same height and will split each bar into the proportions within each bar of the different groups (only one if `group.by = NULL` and as many groups if `group.by` is used). Therefore, it becomes highly recommended to use `position = "stack"` when `group.by` is not used and `position = "fill"` otherwise. This is also warned by the package. If you want to silence the warnings, use `verbose = FALSE`. 

```{r, fig.cap = "SCpubr Bar plots, difference between position", fig.width=12, fig.height=12}
# We are going to use the previously generated sample assignment.

p1 <- SCpubr::do_BarPlot(sample, 
                        feature = "modified_orig.ident",
                        plot.title = "Without group.by - position = stack",
                        position = "stack",
                        legend = T,
                        horizontal = F)

p2 <- SCpubr::do_BarPlot(sample, 
                        feature = "modified_orig.ident",
                        plot.title = "Without group.by - position = fill",
                        position = "fill",
                        legend = T,
                        horizontal = F)

p3 <- SCpubr::do_BarPlot(sample, 
                        feature = "modified_orig.ident",
                        group.by = "seurat_clusters",
                        plot.title = "With group.by - position = stack",
                        position = "stack",
                        legend = T,
                        horizontal = F)

p4 <- SCpubr::do_BarPlot(sample, 
                        feature = "modified_orig.ident",
                        group.by = "seurat_clusters",
                        plot.title = "With group.by - position = fill",
                        position = "fill",
                        legend = T,
                        horizontal = F)
p <- (p1 | p2) / (p3 | p4)
p
```


