#' Create enrichment scores heatmaps.
#'
#' This function computes the enrichment scores for the cells using \link[Seurat]{AddModuleScore} and then aggregates the scores by the metadata variables provided by the user and displays it as a heatmap, computed by \link[ComplexHeatmap]{Heatmap}.
#'
#' @param sample Your Seurat object.
#' @param list_genes Named list of genes to query to the Seurat object.
#' @param group.by Metadata variable to group the values by.
#' @param split.by Metadata variable to split the values of group.by into as many individual heatmaps as unique values in split.by.
#' @param split.horizontal Logical. Join the individual heatmaps generated by split.by horizontally (TRUE) or vertically (FALSE).
#' @param column_title,row_title Title for the columns and rows. Only works with single heatmaps.
#' @param verbose Extended output.
#' @param transpose Logical. Transpose the resulting heatmap.
#' @param cluster_cols,cluster_rows Logical. Cluster the columns or rows.
#' @param column_names_rot,row_names_rot Numeric. Degree in which to
#' @param legend_name Text for the legend title.
#' @param colors.use Vector of 2 colors to use to generate the color scale.
#' @param cell_size Numeric. Size of each cell in the heatmap.
#' @return A ComplexHeatmap object.
#' @export
#'
#' @example /man/examples/examples_do_EnrichmentHeatmap.R
do_EnrichmentHeatmap <- function(sample,
                                 list_genes,
                                 group.by = NULL,
                                 split.by = NULL,
                                 split.horizontal = TRUE,
                                 column_title = NULL,
                                 row_title = NULL,
                                 verbose = FALSE,
                                 transpose = FALSE,
                                 cluster_cols = TRUE,
                                 cluster_rows = FALSE,
                                 legend_name = "Enrichment",
                                 row_names_rot = 0,
                                 column_names_rot = 90,
                                 colors.use = NULL,
                                 cell_size = 5){
  # Checks for packages.
  check_suggests(function_name = "do_EnrichmentHeatmap")
  # Check if the sample provided is a Seurat object.
  check_Seurat(sample = sample)

  # Check logical parameters.
  logical_list <- list("split.horizontal" = split.horizontal,
                       "cluster_cols" = cluster_cols,
                       "cluster_rows" = cluster_rows)
  check_type(parameters = logical_list, required_type = "logical", test_function = is.logical)
  # Check numeric parameters.
  numeric_list <- list("row_names_rot" = row_names_rot,
                       "column_names_rot" = column_names_rot,
                       "cell_size" = cell_size)
  check_type(parameters = numeric_list, required_type = "numeric", test_function = is.numeric)
  # Check character parameters.
  character_list <- list("list_genes" = list_genes,
                         "column_title" = column_title,
                         "row_title" = row_title,
                         "legend_name" = legend_name,
                         "colors.use" = colors.use,
                         "group.by" = group.by,
                         "split.by" = split.by)
  check_type(parameters = character_list, required_type = "character", test_function = is.character)

  `%v%` <- ComplexHeatmap::`%v%`
  `%>%` <- purrr::`%>%`

  if (is.character(list_genes)){
    # If list_genes is a character of genes.
    input_list <- list_genes
    names(input_list) <- list_genes
  } else if (is.list(list_genes)){
    input_list <- list_genes
    if (is.null(names(input_list))){
      stop("Please provide a named list. This is, each gene list has to come with a name.", call. = F)
    }
  }

  # Compute the enrichment scores.
  sample <- compute_enrichment_scores(sample = sample, list_genes = list_genes, verbose = verbose)

  # Start the process.
  if (is.null(group.by)){
    aggr_entities <- levels(sample)
    sample@meta.data[, "dummy"] <- sample@active.ident
    group.by <- "dummy"
  } else {
    if (is.factor(sample@meta.data[, group.by])){
      aggr_entities <- levels(sample@meta.data[, group.by])
    } else {
      aggr_entities <- sort(unique(sample@meta.data[, group.by]))
    }
  }

  # If only 1 row or column, it can not be clustered.
  if (length(aggr_entities) == 1){
    cluster_cols <- FALSE
    cluster_rows <- FALSE
  }

  # Get the maximum range of the data.
  scoring <- data.frame("rownames" = aggr_entities) # This is to compute the overall maximum.

  metadata <-  sample@meta.data
  # Iterate over each marker gene list.
  for (celltype in names(input_list)){
    # Generate empty vectors for the aggregated scores.
    list_score_seurat <- c()

    # Iterate over each cluster.
    for (cluster_name in aggr_entities){
      # Retrieve which cells are assigned to the cluster.
      scores_seurat <- metadata %>% dplyr::filter(!!rlang::sym(group.by) == cluster_name) %>% dplyr::select(!!rlang::sym(celltype))


      # Append to the vector the mean for each cell type.
      list_score_seurat <- append(list_score_seurat, mean(scores_seurat[,1]))
    }
    # Get the name of the column together with the number of genes used for the enrichment scoring.
    scoring[celltype] <- list_score_seurat
  }


  # Remove the rownames column in the object, since you set them to be the rownames of the dataframe.
  rownames(scoring) <- scoring$rownames
  scoring$rownames <- NULL

  # Transform the data frames into a Matrix object.
  scoring <- as.matrix(scoring)

  # Get the maximum range.
  range <- max(abs(scoring))

  if (is.null(split.by)){
    row_title <- {
      if (!(is.null(row_title))){
        row_title
      } else {
        ""
      }}

    column_title <- {
      if (!(is.null(column_title))){
        column_title
      } else {
        ""
      }}
    if (isTRUE(transpose)){
      data <- t(scoring)
    } else {
      data <- scoring
    }


    out <- heatmap_inner(data,
                         legend_name = legend_name,
                         column_title = column_title,
                         row_title = row_title,
                         cluster_columns = cluster_cols,
                         cluster_rows = cluster_rows,
                         column_names_rot = column_names_rot,
                         row_names_rot = row_names_rot,
                         colors.use = colors.use,
                         cell_size = cell_size)
    h <- out[["heatmap"]]
    h_legend <- out[["legend"]]
    ComplexHeatmap::ht_opt("HEATMAP_LEGEND_PADDING" = ggplot2::unit(8, "mm"))
    suppressWarnings({
      grDevices::pdf(NULL)
      h <- ComplexHeatmap::draw(h,
                                heatmap_legend_list = h_legend,
                                padding = ggplot2::unit(c(5, 5, 5, 5), "mm"))
      grDevices::dev.off()
    })


    return(h)
  }  else {
    # Compute heatmaps for split values.
    split.values <- as.character(sort(unique(sample@meta.data %>% dplyr::pull(!!rlang::sym(split.by)))))
    list.heatmaps <- list()
    for (split.value in split.values){
      scoring.split <- data.frame("rownames" = aggr_entities) # This is the actual heatmap.

      metadata.split <- sample@meta.data %>% dplyr::filter(!!rlang::sym(split.by) == split.value)

      # Iterate over each marker gene list.
      for (celltype in names(input_list)){
        # Generate empty vectors for the aggregated scores.
        list_score_seurat_split <- c()

        # Iterate over each cluster.
        for (cluster_name in aggr_entities){
          # Retrieve which cells are assigned to the cluster.
          scores_seurat_split <- metadata.split %>% dplyr::filter(!!rlang::sym(group.by) == cluster_name) %>% dplyr::select(!!rlang::sym(celltype))

          # Append to the vector the mean for each cell type.
          list_score_seurat_split <- append(list_score_seurat_split, mean(scores_seurat_split[, 1]))
        }
        # Get the name of the column together with the number of genes used for the enrichment scoring.
        scoring.split[celltype] <- list_score_seurat_split
      }


      # Remove the rownames column in the object, since you set them to be the rownames of the dataframe.
      scoring.split[is.na(scoring.split)] <- 0
      rownames(scoring.split) <- scoring.split$rownames
      scoring.split$rownames <- NULL

      # Transform the data frames into a Matrix object.
      scoring.split <- as.matrix(scoring.split)

      row_title <- {
        if (!(is.null(row_title))){
          row_title
        } else {
          ""
        }}

      column_title <- {
        if (!(is.null(column_title))){
          column_title
        } else {
          ""
        }}

      if (isTRUE(transpose)){
        data <- t(scoring.split)
      } else {
        data <- scoring.split
      }

      if (isTRUE(split.horizontal)){
        row_title <- ""
        column_title <- split.value
      } else {
        row_title <- split.value
        column_title <- ""
      }


      out <- heatmap_inner(data,
                           legend_name = legend_name,
                           column_title = column_title,
                           row_title = row_title,
                           row_title_side = "right",
                           row_title_rotation = 0,
                           column_names_rot = column_names_rot,
                           row_names_rot = row_names_rot,
                           range.data = range,
                           cluster_columns = cluster_cols,
                           cluster_rows = cluster_rows,
                           colors.use = colors.use,
                           cell_size = cell_size)
      h <- out[["heatmap"]]
      h_legend <- out[["legend"]]

      list.heatmaps[[split.value]] <- h
    }
    ComplexHeatmap::ht_opt("HEATMAP_LEGEND_PADDING" = ggplot2::unit(8, "mm"))
    suppressWarnings({
      grDevices::pdf(NULL)
      ht_list <- NULL
      for (name in names(list.heatmaps)){
        if (isTRUE(split.horizontal)){
          ht_list = ht_list + list.heatmaps[[name]]
        } else if (isFALSE(split.horizontal)){
          ht_list = ht_list %v% list.heatmaps[[name]]
        }
      }
      h <- ComplexHeatmap::draw(ht_list,
                                heatmap_legend_list = h_legend,
                                padding = ggplot2::unit(c(5, 5, 5, 5), "mm"))
      grDevices::dev.off()
    })

    return(h)
  }
}
