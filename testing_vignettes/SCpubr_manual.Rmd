---
title: "Complete reference guide to SCpubr"
shorttitle: "SCpubr"
author: "Enrique Blanco Carmona"
affiliation: "e.blancocarmona@kitz-heidelberg.de"
package: SCpubr
output: 
  BiocStyle::html_document:
    toc_float: true
    theme: "flatly"
    code_folding: show
    fig_width: 12
    fig_height: 12
    fig_caption: true
vignette: >
  %\VignetteIndexEntry{Complete reference guide to SCpubr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}  
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE
)
```

# Aim of this package
This package aims to provide a streamlined way of generating publication ready figures for known single-cell visualizations. As subjective as the term "aesthetically pleasant" can be, this a set of theme modifications implemented across different plot types. This package also serves as a personal project, with future prospects of growth.

# Dataset used

Through this vignette, a dataset containing 10K raw cells is used, which can be downloaded [here](https://www.10xgenomics.com/resources/datasets/10k-human-pbmcs-3-ht-v3-1-chromium-x-3-1-high).

The following code is used to generate a Seurat object ready for plotting.

```{r Seurat object generation, eval = F}
counts_path <- "path_to_count_matrix"

# Path count matrix.
counts <- Seurat::Read10X(counts_path)
# Create Seurat object.
sample <- Seurat::CreateSeuratObject(counts = counts, project = "10K_pbmc")
# Compute percentage of mithochondrial RNA.
sample <- Seurat::PercentageFeatureSet(sample, pattern = "^MT-", col.name = "percent.mt")
# Compute QC.
mask1 <- sample$nCount_RNA >= 1000
mask2 <- sample$nFeature_RNA >= 500
mask3 <- sample$percent.mt <= 20
mask <- mask1 & mask2 & mask3
sample <- sample[, mask]
# Normalize.
sample <- Seurat::SCTransform(sample)

# Dimensional reduction.
sample <- Seurat::RunPCA(sample)
sample <- Seurat::RunUMAP(sample, dims = 1:30)
# Find clusters.
sample <- Seurat::FindNeighbors(sample, dims = 1:30)
sample <- Seurat::FindClusters(sample, resolution = 0.2)
```


# do_DimPlot()
## Regular DimPlot
### Build up
```{r echo = F}
sample <- readRDS("/b06x-isilon/b06x-g/G703/eblanco/projects/test_SC_datasets/sc_dataset.rds")
```
This function aims to enhance Seurat's `DimPlot()` output.

This is Seurat's default output for `DimPlot()`. 
```{r, fig.cap = "Default DimPlot."}
Seurat::DimPlot(sample)
```

As it looks, there is nothing wrong, but there are quite some changes that one would like to implement. For instance, shuffling the cells so that there is no overlap of cells just due to the cluster names.

```{r, fig.cap = "DimPlot with the cells shuffled."}
Seurat::DimPlot(sample, shuffle = T)
```

Furthermore, one would think about the *need* of the axes. If, by consensus, UMAPs are shown plotting the first UMAP component on the X axis and the second on the Y axis, then showing them becomes redundant, specially when one can not truly rely on the numbers shown by the scales. 

```{r, fig.cap = "DimPlot without axes."}
Seurat::DimPlot(sample, shuffle = T) + Seurat::NoAxes()
```

Right now, we can observe a couple of things. First, is that the dot size is rather small. Let's set it to 0.5.

```{r, fig.cap = "DimPlot with increased dot size."}
Seurat::DimPlot(sample, shuffle = T, pt.size = 0.5) + Seurat::NoAxes()
```

Still, the legend seems rather small. Let's increase it's font size and set it to bold so that it can better read.

```{r, fig.cap = "DimPlot with increased font size."}
Seurat::DimPlot(sample, shuffle = T, pt.size = 0.5) + 
  Seurat::NoAxes() +
  ggplot2::theme(legend.text = ggplot2::element_text(size = 16, face = "bold"),
                 legend.title = ggplot2::element_text(size = 16, face = "bold"))
```

We would also like to add a title to our plot, to best describe it.

```{r, fig.cap = "DimPlot with title."}
Seurat::DimPlot(sample, shuffle = T, pt.size = 0.5) + 
  Seurat::NoAxes() +
  ggplot2::ggtitle("My awesome SC dataset") +
  ggplot2::theme(legend.text = ggplot2::element_text(size = 16, face = "bold"),
                 legend.title = ggplot2::element_text(size = 16, face = "bold"))
```

And, naturally, we would like to increase the font size of the title and put it in bold and centered.

```{r, fig.cap = "DimPlot with bigger and bold title."}
Seurat::DimPlot(sample, shuffle = T, pt.size = 0.5) + 
  Seurat::NoAxes() +
  ggplot2::ggtitle("My awesome SC dataset") +
  ggplot2::theme(plot.title = ggplot2::element_text(size = 20, face = "bold", hjust = 0.5),
                 legend.text = ggplot2::element_text(size = 16, face = "bold"),
                 legend.title = ggplot2::element_text(size = 16, face = "bold"))
```

Now, we would like to modify the color palette. This palette has too bright colors, and we want something more toned down.

```{r, fig.cap = "DimPlot with custom color scale."}
num_clusters <- length(unique(sample$seurat_clusters))
color_scale <- colortools::setColors("#457b9d", num_clusters)
names(color_scale) <- sort(unique(sample$seurat_clusters))

Seurat::DimPlot(sample, shuffle = T, pt.size = 0.5, cols = color_scale) + 
  Seurat::NoAxes() +
  ggplot2::ggtitle("My awesome SC dataset") +
  ggplot2::theme(plot.title = ggplot2::element_text(size = 20, face = "bold", hjust = 0.5),
                 legend.text = ggplot2::element_text(size = 16, face = "bold"),
                 legend.title = ggplot2::element_text(size = 16, face = "bold"))
```

The legend on the right side seems off, what if we were to have long cluster names? It would inevitable take a lot of space from the actual plot. Let's better put it on the bottom.

```{r, fig.cap = "DimPlot with legend at the bottom."}
num_clusters <- length(unique(sample$seurat_clusters))
color_scale <- colortools::setColors("#457b9d", num_clusters)
names(color_scale) <- sort(unique(sample$seurat_clusters))

Seurat::DimPlot(sample, shuffle = T, pt.size = 0.5, cols = color_scale) + 
  ggpubr::theme_pubr(legend = "bottom") +
  Seurat::NoAxes() +
  ggplot2::ggtitle("My awesome SC dataset") +
  ggplot2::theme(plot.title = ggplot2::element_text(size = 20, face = "bold", hjust = 0.5),
                 legend.text = ggplot2::element_text(size = 16, face = "bold"),
                 legend.title = ggplot2::element_text(size = 16, face = "bold"))
```

Still, there are too many columns in the legend. Let's rearrange it into four columns.

```{r, fig.cap = "DimPlot with legend at the bottom in four columns."}
num_clusters <- length(unique(sample$seurat_clusters))
color_scale <- colortools::setColors("#457b9d", num_clusters)
names(color_scale) <- sort(unique(sample$seurat_clusters))

Seurat::DimPlot(sample, shuffle = T, pt.size = 0.5, cols = color_scale) + 
  ggpubr::theme_pubr(legend = "bottom") +
  Seurat::NoAxes() +
  ggplot2::ggtitle("My awesome SC dataset") +
  ggplot2::theme(plot.title = ggplot2::element_text(size = 20, face = "bold", hjust = 0.5),
                 legend.text = ggplot2::element_text(size = 16, face = "bold"),
                 legend.title = ggplot2::element_text(size = 16, face = "bold")) + 
  ggplot2::guides(color = ggplot2::guide_legend(ncol = 4,
                                                byrow = F))
```

But now the legend icon sizes are too small! We have to fix this.

```{r, fig.cap = "DimPlot with legend at the bottom in four columns."}
num_clusters <- length(unique(sample$seurat_clusters))
color_scale <- colortools::setColors("#457b9d", num_clusters)
names(color_scale) <- sort(unique(sample$seurat_clusters))

Seurat::DimPlot(sample, shuffle = T, pt.size = 0.5, cols = color_scale) + 
  ggpubr::theme_pubr(legend = "bottom") +
  Seurat::NoAxes() +
  ggplot2::ggtitle("My awesome SC dataset") +
  ggplot2::theme(plot.title = ggplot2::element_text(size = 20, face = "bold", hjust = 0.5),
                 legend.text = ggplot2::element_text(size = 16, face = "bold"),
                 legend.title = ggplot2::element_text(size = 16, face = "bold")) + 
  ggplot2::guides(color = ggplot2::guide_legend(ncol = 4,
                                                byrow = F,
                                                override.aes = list(size = 4)))
```

As of now, this plot looks much better and polished than the default counterpart. This, is the setting ground for `SCpubr::do_DimPlot()`. 

### Functionalities

This is the default output from `SCpubr::do_DimPlot()`. 

```{r, fig.cap = "SCpubr DimPlot."}
SCpubr::do_DimPlot(sample)
```

We can add a title with the `plot.title` parameter.

```{r, fig.cap = "SCpubr DimPlot with title."}
SCpubr::do_DimPlot(sample, plot.title = "My awesome SC data set")
```

We can change the legend location and number of columns with `legend.position` and `legend.ncol`.

```{r, fig.cap = "SCpubr DimPlot with legend to the left."}
SCpubr::do_DimPlot(sample, 
                   plot.title = "My awesome SC data set", 
                   legend.position = "left", 
                   legend.ncol = 4)
```

## Highlighting cells.
One of the nice features of `Seurat::DimPlot()` is the possibility of highlighting a certain group of cells in the DimPlot. This is achieved by using the `cells.highligh` parameter. This is how the default plot looks like.

```{r, fig.cap = "Seurat DimPlot highlighting cells."}
# Select 1000 random cells out of clusters 1, 5 and 7.
cells.use <- sample(colnames(sample[, sample$seurat_clusters %in% c("1", "5", "7")]), 1000)
Seurat::DimPlot(sample, cells.highlight = cells.use)
```

This is how SCpubr returns this plot. For this, the same parameter has to be set up.

```{r, fig.cap = "SCpubr DimPlot highlighting cells."}
# Select 1000 random cells out of clusters 1, 5 and 7.
cells.use <- sample(colnames(sample[, sample$seurat_clusters %in% c("1", "5", "7")]), 1000)
SCpubr::do_DimPlot(sample, cells.highlight = cells.use)
```

By default, the size of all cells in `SCpubr::do_DimPlot()` is the same. However, the size of the highlighted dots can be modified with the parameter `sizes.highlight` from Seurat.

```{r, fig.cap = "SCpubr DimPlot highlighting cells bigger dot size."}
# Select 1000 random cells out of clusters 1, 5 and 7.
cells.use <- sample(colnames(sample[, sample$seurat_clusters %in% c("1", "5", "7")]), 1000)
SCpubr::do_DimPlot(sample, cells.highlight = cells.use, sizes.highlight = 2)
```

## Splitting by a category.
Another useful paramter of `Seurat::DimPlot` is `split.by`, which allows you to split your DimPlot into multiple panels, each one containing a different unique value of the metadata variable you have provided to the argument. One can understand this as using the `group.by` parameter and then splitting the resulting DimPlot into different panels. In this example, we are going to use the different clusters as an example This is how it looks by default:

```{r, fig.cap = "Seurat DimPlot using split.by.", fig.width=10, fig.height=5}
# Using ncol = 5 to maintain some of the proportions. 
Seurat::DimPlot(sample, split.by = "seurat_clusters", ncol = 5)
```
As can be observed, this plots accomplish the task of separating the cells into each panel, but the approach followed actually makes interpretation difficult. Clusters such as Cluster 9, with fewer cells, tell pretty much nothing. Not knowing how the original UMAP looked like is a major downside of this approach. This is where `SCpubr` focus. Instead of using `Seurat`'s `split.by` parameter, it generates as many plots as unique values in the metadata to split the plot by, but uses `cells.highlight` instead, which keeps the rest of cells greyed out. This is how it looks:

```{r, fig.cap = "SCpubr DimPlot using split.by.", fig.width=10, fig.height=5}
# Using ncol = 5 to maintain some of the proportions.
# Using legend = F to remove unwanted repeated legends.
SCpubr::do_DimPlot(sample, split.by = "seurat_clusters", ncol = 5, legend = F)
```

This way, we can see that clusters such as Cluster 7 are way more disperse than the rest, accounting not only for standalone groups of cells but also blending in other bigger clusters. Actually, the user might want to change the color of the highlighted cells in this split DimPlot. This is achieved by using `colors.split` parameter and providing either a color name recognized by `ggplot2` or (recommended) a HEX code.


```{r, fig.cap = "SCpubr DimPlot using split.by with a changed color", fig.width=10, fig.height=5}
# Using ncol = 5 to maintain some of the proportions.
# Using legend = F to remove unwanted repeated legends.
SCpubr::do_DimPlot(sample, split.by = "seurat_clusters", ncol = 5, legend = F, colors.split = "black")
```



Furthermore, one might also want to color each cluster by the original color. This can be achieved by using the argument `colorss.split`, either providing a named vector of each cluster (or metadata variable unique value) as names and color hex codes as values or `TRUE`, thus resorting to the default `SCpubr` categorical coloring. 

```{r, fig.cap = "SCpubr DimPlot using split.by with default SCpubr colors", fig.width=10, fig.height=5}
# Using ncol = 5 to maintain some of the proportions.
# Using legend = F to remove unwanted repeated legends.
SCpubr::do_DimPlot(sample, split.by = "seurat_clusters", ncol = 5, legend = F, colors.split = TRUE)
```

```{r, fig.cap = "SCpubr DimPlot using split.by using custom list of colors", fig.width=10, fig.height=5}
# Using ncol = 5 to maintain some of the proportions.
# Using legend = F to remove unwanted repeated legends.
colors.use <- RColorBrewer::brewer.pal(length(unique(sample$seurat_clusters)), "Paired")
names(colors.use) <- levels(sample$seurat_clusters)
SCpubr::do_DimPlot(sample, split.by = "seurat_clusters", ncol = 5, legend = F, colors.split = colors.use)
```

## Adding labels to the cluster instead of using the legend.
In some cases, what we want is an indication of which cluster is what, right on top of it. That, sometimes, makes visualizations clearer. It has several downsides, the most important being that the label is located around the highest density point of the cells in the cluster. If the clusters are scattered across the UMAP, this might result in "errant" labels, misplaced. Also, when one has really long cluster names or a lot of clusters, the plot might quickly become crowded. This plot is accomplished by using `label = T` to label the clusters, `repel = T` to avoid overlapping of labels and `Seurat::NoLegend()` to remove the legend.

```{r, fig.cap = "Seurat DimPlot using labels."}
# Using ncol = 5 to maintain some of the proportions.
# Using legend = F to remove unwanted repeated legends.
Seurat::DimPlot(sample, label = T, repel = T) + Seurat::NoLegend()
```
This is, in turn, how `SCpubr` returns this kind of plot. Note that `repel = T` is set by default.

```{r, fig.cap = "Seurat DimPlot using labels."}
SCpubr::do_DimPlot(sample, label = T, legend = F)
```


# do_FeaturePlot()
## Build up

Another broadly used function in `Seurat` is `Seurat::FeaturePlot()`. It is a very similar function to `Seurat::DimPlot()` which instead of coloring the cells based on a categorical color scale, it uses a continuous one, according to a variable provided by the user. This can range from gene expression, to metadata variables such as the number of genes, or even values such as PC_1. This is how it looks, plotting the number of UMIs.

```{r, fig.cap= "Seurat FeaturePlot"}
Seurat::FeaturePlot(sample, features = "nCount_RNA")
```
First thing that stands out, it that the color scale could be changed to one with two very opposite ends, so that identifying regions with low and high UMIs become an easier task. Apart from that, we want apply the same treatment as in `do_DimPlot()` section. 

```{r, fig.cap= Seurat FeaturePlot, with new color scale and general modifications}
Seurat::FeaturePlot(sample, features = "nCount_RNA") + 
  Seurat::NoAxes() + 
  viridis::scale_color_viridis()
```

This way, we can observe that most of the clusters have a really similar number of UMIs, despite selected ones which have up to 4 times more. These could very well be doublets. This is `SCpubr::do_FeaturePlot()` variation:

```{r, fig.cap = "SCpubr FeaturePlot, with minor modifications"}
SCpubr::do_FeaturePlot(sample, features = "nCount_RNA", plot.title = "Number of UMIs")
```

By default, `SCpubr` enlarges the dots a bit and makes the legend bold, to better stand out. 

## Multiple features

`SCpubr::do_FeaturePlot()` can tackle multiple queries at the same time. Plots can be rearranged as desired with `ncol` parameter:

```{r, fig.cap = "SCpubr FeaturePlot, with 4 features and 2 columns"}
SCpubr::do_FeaturePlot(sample, features = c("nCount_RNA", "nFeature_RNA", "percent.mt", "CD14"), plot.title = "My very important features", ncol = 2)
```

With multiple queries, using `plot.title` parameter actually adds an overall title. If one wants to modify the title of each plot independently, a more complex approach is needed, which requires more R expertise, using `patchwork` package.

```{r, fig.cap = "SCpubr FeaturePlot, with individual modified titles"}
((SCpubr::do_FeaturePlot(sample, features = "nCount_RNA", plot.title = "Plot A") | SCpubr::do_FeaturePlot(sample, features = "nFeature_RNA", plot.title = "Plot B")) /
(SCpubr::do_FeaturePlot(sample, features = "percent.mt", plot.title = "Plot C") | SCpubr::do_FeaturePlot(sample, features = "CD14", plot.title = "Plot D"))) + 
patchwork::plot_annotation(title = "My very important features", theme = ggplot2::theme(plot.title = ggplot2::element_text(size = 18, face = "bold", hjust = 0.5)))

```

## Working with subsets of cells

One of the things that can be misleading, is that it could be the case that a very specific subset of cells are driving the ends of the color scales. Let's say that we have identified that clusters 2, 5, and 8 are responsible of this behavior. We would like to have plot the values without taking those cells into consideration. The very first thing that comes to mind is, indeed, removing the cells completely, resulting in the following:

```{r, fig.cap = "SCpubr FeaturePlot, removing cells from clusters 2, 5 and 8"}
cells.plot <- colnames(sample[, !(sample$seurat_clusters %in% c("2", "5", "8"))])
SCpubr::do_FeaturePlot(sample[, cells.plot], features = c("CD14"), plot.title = "My very important features")
```

However, this falls back to the same problem as with `Seurat::DimPlot` with the `split.by` parameter. We lose the overall context of where the cells are. This is taken care by in `SCpubr::do_FeaturePlot()`, when using the `cells.highlight` parameter:

```{r, fig.cap = "SCpubr FeaturePlot, masking cells from clusters 2, 5 and 8"}
cells.plot <- colnames(sample[, !(sample$seurat_clusters %in% c("2", "5", "8"))])
SCpubr::do_FeaturePlot(sample, cells.highlight = cells.plot, features = c("CD14"), plot.title = "My very important features")
```
This way, by adding the cells back and modifying the legend, we accomplish the desired effect. Furthermore, `SCpubr::do_FeaturePlot()` also accepts a vector of the identities to plot, as long as they are part of `levels(seurat_object)`. This can be achieved by using the `idents.highlight` instead.

```{r, fig.cap = "SCpubr FeaturePlot, masking cells from clusters 2, 5 and 8 using idents.highlight"}

SCpubr::do_FeaturePlot(sample, idents.highlight = levels(sample)[!(levels(sample) %in% c("2", "5", "8"))], features = c("CD14"), plot.title = "My very important features")
```

# do_NebulosaPlot()

This plot comes straight from the [Nebulosa package](http://bioconductor.org/packages/release/bioc/html/Nebulosa.html). For more information, here is their [vignette](http://bioconductor.org/packages/release/bioc/vignettes/Nebulosa/inst/doc/nebulosa_seurat.html). In short, it computes a "density" of whether the surrounding cells (in the UMAP embedding) also express the variable that you provide to the function, same variables that one could feed to `Seurat::FeaturePlot()`. This is how their default plot looks like:

```{r, fig.cap= "Nebulosa plot"}
Nebulosa::plot_density(sample, "CD14")
```

This way, not only we do know which clusters are enriched in CD14, we also know the regions of it with the hightest density of cells expressing it. Minor modifications, on the line of the rest of plots, are applied in `SCpubr`:
```{r, fig.cap = "SCpubr Nebulosa plot."}
SCpubr::do_Nebulosa_plot(sample, features = "CD14")
```



# do_RankPlot()
Instert deep explanation here.

```{r, fig.cap = "SCpubr BeeSwarm plot"}
SCpubr::do_BeeSwarmPlot(sample, feature_to_rank = "PC_25", group.by = "seurat_clusters", continuous_feature = TRUE)
```



# do_DotPlot()

# do_VlnPlot()

# do_BarPlot()

# do_ButterflyPlot()

# do_PTEA()



```{r setup}
library(SCpubr)
```
