[["index.html", "SCpubr - Complete reference Chapter 1 Aim of the package", " SCpubr - Complete reference Enrique Blanco Carmona 2022-02-13 Chapter 1 Aim of the package This package aims to provide a streamlined way of generating publication ready figures for known single-cell visualizations. As subjective as the term “aesthetically pleasant” can be, this a set of theme modifications implemented across different plot types. This package also serves as a personal project, with future prospects of growth. "],["installation-guide.html", "Chapter 2 Installation guide 2.1 A section 2.2 Another section", " Chapter 2 Installation guide TBD 2.1 A section 2.2 Another section "],["dataset.html", "Chapter 3 Dataset", " Chapter 3 Dataset Through this vignette, a dataset containing 10K raw cells is used, which can be downloaded here. The following code is used to generate a Seurat object ready for plotting. counts_path &lt;- &quot;path_to_count_matrix&quot; # Path count matrix. counts &lt;- Seurat::Read10X(counts_path) # Create Seurat object. sample &lt;- Seurat::CreateSeuratObject(counts = counts, project = &quot;10K_pbmc&quot;) # Compute percentage of mithochondrial RNA. sample &lt;- Seurat::PercentageFeatureSet(sample, pattern = &quot;^MT-&quot;, col.name = &quot;percent.mt&quot;) # Compute QC. mask1 &lt;- sample$nCount_RNA &gt;= 1000 mask2 &lt;- sample$nFeature_RNA &gt;= 500 mask3 &lt;- sample$percent.mt &lt;= 20 mask &lt;- mask1 &amp; mask2 &amp; mask3 sample &lt;- sample[, mask] # Normalize. sample &lt;- Seurat::SCTransform(sample) # Dimensional reduction. sample &lt;- Seurat::RunPCA(sample) sample &lt;- Seurat::RunUMAP(sample, dims = 1:30) # Find clusters. sample &lt;- Seurat::FindNeighbors(sample, dims = 1:30) sample &lt;- Seurat::FindClusters(sample, resolution = 0.2) "],["dimplots.html", "Chapter 4 DimPlots 4.1 Regular DimPlots 4.2 Highlighting cells 4.3 Splitting by a category", " Chapter 4 DimPlots DimPlots are, probably, one of the most iconic visualizations from Seurat. It allows the user to visualize the cells in a dimensional reduction embedding such as PCA or UMAP. The cells can be, then, colored by any desired groups. In short, this visualization allows the user to plot any kind of categorical data onto the cells in the dimesional reduction embedding. This is achieved by using Seurat::DimPlot() funtion: Seurat::DimPlot(sample) Figure 4.1: Default DimPlot. Overall, this is a pretty neat visualization, but there are quite some changes that one would like to implement. For instance, shuffling the cells so that there is no overlap of cells just due to the cluster names. Seurat::DimPlot(sample, shuffle = T) Figure 4.2: DimPlot with the cells shuffled. Furthermore, one would think about the need of the axes. If, by consensus, UMAPs are shown plotting the first UMAP component on the X axis and the second on the Y axis, then showing them becomes redundant, specially when one can not truly rely on the numbers shown by the scales. Seurat::DimPlot(sample, shuffle = T) + Seurat::NoAxes() Figure 4.3: DimPlot without axes. Right now, we can observe a couple of things. First, is that the dot size is rather small. Let’s set it to 0.5. Seurat::DimPlot(sample, shuffle = T, pt.size = 0.5) + Seurat::NoAxes() Figure 4.4: DimPlot with increased dot size. Still, the legend seems rather small. Let’s increase it’s font size and set it to bold so that it can better read. Seurat::DimPlot(sample, shuffle = T, pt.size = 0.5) + Seurat::NoAxes() + ggplot2::theme(legend.text = ggplot2::element_text(size = 16, face = &quot;bold&quot;), legend.title = ggplot2::element_text(size = 16, face = &quot;bold&quot;)) Figure 4.5: DimPlot with increased font size. We would also like to add a title to our plot, to best describe it. Seurat::DimPlot(sample, shuffle = T, pt.size = 0.5) + Seurat::NoAxes() + ggplot2::ggtitle(&quot;My awesome SC dataset&quot;) + ggplot2::theme(legend.text = ggplot2::element_text(size = 16, face = &quot;bold&quot;), legend.title = ggplot2::element_text(size = 16, face = &quot;bold&quot;)) Figure 4.6: DimPlot with title. And, naturally, we would like to increase the font size of the title and put it in bold and centered. Seurat::DimPlot(sample, shuffle = T, pt.size = 0.5) + Seurat::NoAxes() + ggplot2::ggtitle(&quot;My awesome SC dataset&quot;) + ggplot2::theme(plot.title = ggplot2::element_text(size = 20, face = &quot;bold&quot;, hjust = 0.5), legend.text = ggplot2::element_text(size = 16, face = &quot;bold&quot;), legend.title = ggplot2::element_text(size = 16, face = &quot;bold&quot;)) Figure 4.7: DimPlot with bigger and bold title. Now, we would like to modify the color palette. This palette has too bright colors, and we want something more toned down. num_clusters &lt;- length(unique(sample$seurat_clusters)) color_scale &lt;- colortools::setColors(&quot;#457b9d&quot;, num_clusters) names(color_scale) &lt;- sort(unique(sample$seurat_clusters)) Seurat::DimPlot(sample, shuffle = T, pt.size = 0.5, cols = color_scale) + Seurat::NoAxes() + ggplot2::ggtitle(&quot;My awesome SC dataset&quot;) + ggplot2::theme(plot.title = ggplot2::element_text(size = 20, face = &quot;bold&quot;, hjust = 0.5), legend.text = ggplot2::element_text(size = 16, face = &quot;bold&quot;), legend.title = ggplot2::element_text(size = 16, face = &quot;bold&quot;)) Figure 4.8: DimPlot with custom color scale. The legend on the right side seems off, what if we were to have long cluster names? It would inevitable take a lot of space from the actual plot. Let’s better put it on the bottom. num_clusters &lt;- length(unique(sample$seurat_clusters)) color_scale &lt;- colortools::setColors(&quot;#457b9d&quot;, num_clusters) names(color_scale) &lt;- sort(unique(sample$seurat_clusters)) Seurat::DimPlot(sample, shuffle = T, pt.size = 0.5, cols = color_scale) + ggpubr::theme_pubr(legend = &quot;bottom&quot;) + Seurat::NoAxes() + ggplot2::ggtitle(&quot;My awesome SC dataset&quot;) + ggplot2::theme(plot.title = ggplot2::element_text(size = 20, face = &quot;bold&quot;, hjust = 0.5), legend.text = ggplot2::element_text(size = 16, face = &quot;bold&quot;), legend.title = ggplot2::element_text(size = 16, face = &quot;bold&quot;)) Figure 4.9: DimPlot with legend at the bottom. Still, there are too many columns in the legend. Let’s rearrange it into four columns. num_clusters &lt;- length(unique(sample$seurat_clusters)) color_scale &lt;- colortools::setColors(&quot;#457b9d&quot;, num_clusters) names(color_scale) &lt;- sort(unique(sample$seurat_clusters)) Seurat::DimPlot(sample, shuffle = T, pt.size = 0.5, cols = color_scale) + ggpubr::theme_pubr(legend = &quot;bottom&quot;) + Seurat::NoAxes() + ggplot2::ggtitle(&quot;My awesome SC dataset&quot;) + ggplot2::theme(plot.title = ggplot2::element_text(size = 20, face = &quot;bold&quot;, hjust = 0.5), legend.text = ggplot2::element_text(size = 16, face = &quot;bold&quot;), legend.title = ggplot2::element_text(size = 16, face = &quot;bold&quot;)) + ggplot2::guides(color = ggplot2::guide_legend(ncol = 4, byrow = F)) Figure 4.10: DimPlot with legend at the bottom in four columns. But now the legend icon sizes are too small! We have to fix this. num_clusters &lt;- length(unique(sample$seurat_clusters)) color_scale &lt;- colortools::setColors(&quot;#457b9d&quot;, num_clusters) names(color_scale) &lt;- sort(unique(sample$seurat_clusters)) Seurat::DimPlot(sample, shuffle = T, pt.size = 0.5, cols = color_scale) + ggpubr::theme_pubr(legend = &quot;bottom&quot;) + Seurat::NoAxes() + ggplot2::ggtitle(&quot;My awesome SC dataset&quot;) + ggplot2::theme(plot.title = ggplot2::element_text(size = 20, face = &quot;bold&quot;, hjust = 0.5), legend.text = ggplot2::element_text(size = 16, face = &quot;bold&quot;), legend.title = ggplot2::element_text(size = 16, face = &quot;bold&quot;)) + ggplot2::guides(color = ggplot2::guide_legend(ncol = 4, byrow = F, override.aes = list(size = 4))) Figure 4.11: DimPlot with legend at the bottom in four columns. As of now, this plot looks much better and polished than the default counterpart. This, is the setting ground for SCpubr::do_DimPlot(). 4.1 Regular DimPlots This is the default output from SCpubr::do_DimPlot(). SCpubr::do_DimPlot(sample) Figure 4.12: SCpubr DimPlot. We can add a title with the plot.title parameter. SCpubr::do_DimPlot(sample, plot.title = &quot;My awesome SC data set&quot;) Figure 4.13: SCpubr DimPlot with title. We can change the legend location and number of columns with legend.position and legend.ncol. SCpubr::do_DimPlot(sample, plot.title = &quot;My awesome SC data set&quot;, legend.position = &quot;left&quot;, legend.ncol = 4) Figure 4.14: SCpubr DimPlot with legend to the left. 4.2 Highlighting cells One of the nice features of Seurat::DimPlot() is the possibility of highlighting a certain group of cells in the DimPlot. This is achieved by using the cells.highligh parameter. This is how the default plot looks like. # Select 1000 random cells out of clusters 1, 5 and 7. cells.use &lt;- sample(colnames(sample[, sample$seurat_clusters %in% c(&quot;1&quot;, &quot;5&quot;, &quot;7&quot;)]), 1000) Seurat::DimPlot(sample, cells.highlight = cells.use) Figure 4.15: Seurat DimPlot highlighting cells. This is how SCpubr returns this plot. For this, the same parameter has to be set up. # Select 1000 random cells out of clusters 1, 5 and 7. cells.use &lt;- sample(colnames(sample[, sample$seurat_clusters %in% c(&quot;1&quot;, &quot;5&quot;, &quot;7&quot;)]), 1000) SCpubr::do_DimPlot(sample, cells.highlight = cells.use) Figure 4.16: SCpubr DimPlot highlighting cells. By default, the size of all cells in SCpubr::do_DimPlot() is the same. However, the size of the highlighted dots can be modified with the parameter sizes.highlight from Seurat. # Select 1000 random cells out of clusters 1, 5 and 7. cells.use &lt;- sample(colnames(sample[, sample$seurat_clusters %in% c(&quot;1&quot;, &quot;5&quot;, &quot;7&quot;)]), 1000) SCpubr::do_DimPlot(sample, cells.highlight = cells.use, sizes.highlight = 2) Figure 4.17: SCpubr DimPlot highlighting cells bigger dot size. 4.3 Splitting by a category Another useful paramter of Seurat::DimPlot is split.by, which allows you to split your DimPlot into multiple panels, each one containing a different unique value of the metadata variable you have provided to the argument. One can understand this as using the group.by parameter and then splitting the resulting DimPlot into different panels. In this example, we are going to use the different clusters as an example This is how it looks by default: # Using ncol = 5 to maintain some of the proportions. Seurat::DimPlot(sample, split.by = &quot;seurat_clusters&quot;, ncol = 5) Figure 4.18: Seurat DimPlot using split.by. As can be observed, this plots accomplish the task of separating the cells into each panel, but the approach followed actually makes interpretation difficult. Clusters such as Cluster 9, with fewer cells, tell pretty much nothing. Not knowing how the original UMAP looked like is a major downside of this approach. This is where SCpubr focus. Instead of using Seurat’s split.by parameter, it generates as many plots as unique values in the metadata to split the plot by, but uses cells.highlight instead, which keeps the rest of cells greyed out. This is how it looks: # Using ncol = 5 to maintain some of the proportions. # Using legend = F to remove unwanted repeated legends. SCpubr::do_DimPlot(sample, split.by = &quot;seurat_clusters&quot;, ncol = 5, legend = F) Figure 4.19: SCpubr DimPlot using split.by. This way, we can see that clusters such as Cluster 7 are way more disperse than the rest, accounting not only for standalone groups of cells but also blending in other bigger clusters. Actually, the user might want to change the color of the highlighted cells in this split DimPlot. This is achieved by using colors.split parameter and providing either a color name recognized by ggplot2 or (recommended) a HEX code. # Using ncol = 5 to maintain some of the proportions. # Using legend = F to remove unwanted repeated legends. SCpubr::do_DimPlot(sample, split.by = &quot;seurat_clusters&quot;, ncol = 5, legend = F, colors.split = &quot;black&quot;) Figure 4.20: SCpubr DimPlot using split.by with a changed color Furthermore, one might also want to color each cluster by the original color. This can be achieved by using the argument colorss.split, either providing a named vector of each cluster (or metadata variable unique value) as names and color hex codes as values or TRUE, thus resorting to the default SCpubr categorical coloring. # Using ncol = 5 to maintain some of the proportions. # Using legend = F to remove unwanted repeated legends. SCpubr::do_DimPlot(sample, split.by = &quot;seurat_clusters&quot;, ncol = 5, legend = F, colors.split = TRUE) Figure 4.21: SCpubr DimPlot using split.by with default SCpubr colors "],["featureplots.html", "Chapter 5 FeaturePlots 5.1 Multiple features 5.2 Working with subsets of cells 5.3 Splitting the FeaturePlot by a variable", " Chapter 5 FeaturePlots Another broadly used function in Seurat is Seurat::FeaturePlot(). It is basically the counterpart of Seurat::DimPlot() which instead of coloring the cells based on a categorical color scale, it uses a continuous one, according to a variable provided by the user. This can range from gene expression, to metadata variables such as the number of genes, or even values such as PC_1. This is how it looks, plotting the number of UMIs: Seurat::FeaturePlot(sample, features = &quot;nCount_RNA&quot;) Figure 5.1: Seurat FeaturePlot First thing that stands out, it that the color scale could be changed to one with two very opposite ends, so that identifying regions with low and high UMIs become an easier task. Apart from that, we want apply the same treatment as in do_DimPlot() section. Seurat::FeaturePlot(sample, features = &quot;nCount_RNA&quot;) + Seurat::NoAxes() + viridis::scale_color_viridis() Figure 5.2: Seurat FeaturePlot, with new color scale and general modifications This way, we can observe that most of the clusters have a really similar number of UMIs, despite selected ones which have up to 4 times more. These could very well be doublets. This is SCpubr::do_FeaturePlot() variation: SCpubr::do_FeaturePlot(sample, features = &quot;nCount_RNA&quot;, plot.title = &quot;Number of UMIs&quot;) Figure 5.3: SCpubr FeaturePlot, with minor modifications By default, SCpubr enlarges the dots a bit and makes the legend bold, to better stand out. 5.1 Multiple features SCpubr::do_FeaturePlot() can tackle multiple queries at the same time. Plots can be rearranged as desired with ncol parameter: SCpubr::do_FeaturePlot(sample, features = c(&quot;nCount_RNA&quot;, &quot;nFeature_RNA&quot;, &quot;percent.mt&quot;, &quot;CD14&quot;), plot.title = &quot;My very important features&quot;, ncol = 2) Figure 5.4: SCpubr FeaturePlot, with 4 features and 2 columns With multiple queries, using plot.title parameter actually adds an overall title. If one wants to modify the title of each plot independently, a more complex approach is needed, which requires more R expertise, using patchwork package. ((SCpubr::do_FeaturePlot(sample, features = &quot;nCount_RNA&quot;, plot.title = &quot;Plot A&quot;) | SCpubr::do_FeaturePlot(sample, features = &quot;nFeature_RNA&quot;, plot.title = &quot;Plot B&quot;)) / (SCpubr::do_FeaturePlot(sample, features = &quot;percent.mt&quot;, plot.title = &quot;Plot C&quot;) | SCpubr::do_FeaturePlot(sample, features = &quot;CD14&quot;, plot.title = &quot;Plot D&quot;))) + patchwork::plot_annotation(title = &quot;My very important features&quot;, theme = ggplot2::theme(plot.title = ggplot2::element_text(size = 18, face = &quot;bold&quot;, hjust = 0.5))) Figure 5.5: SCpubr FeaturePlot, with individual modified titles 5.2 Working with subsets of cells One of the things that can be misleading, is that it could be the case that a very specific subset of cells are driving the ends of the color scales. Let’s say that we have identified that clusters 2, 5, and 8 are responsible of this behavior. We would like to have plot the values without taking those cells into consideration. The very first thing that comes to mind is, indeed, removing the cells completely, resulting in the following: cells.plot &lt;- colnames(sample[, !(sample$seurat_clusters %in% c(&quot;2&quot;, &quot;5&quot;, &quot;8&quot;))]) SCpubr::do_FeaturePlot(sample[, cells.plot], features = c(&quot;CD14&quot;), plot.title = &quot;My very important features&quot;) Figure 5.6: SCpubr FeaturePlot, removing cells from clusters 2, 5 and 8 However, this falls back to the same problem as with Seurat::DimPlot with the split.by parameter. We lose the overall context of where the cells are. This is taken care by in SCpubr::do_FeaturePlot(), when using the cells.highlight parameter: cells.plot &lt;- colnames(sample[, !(sample$seurat_clusters %in% c(&quot;2&quot;, &quot;5&quot;, &quot;8&quot;))]) SCpubr::do_FeaturePlot(sample, cells.highlight = cells.plot, features = c(&quot;CD14&quot;), plot.title = &quot;My very important features&quot;) Figure 5.7: SCpubr FeaturePlot, masking cells from clusters 2, 5 and 8 This way, by adding the cells back and modifying the legend, we accomplish the desired effect. Furthermore, SCpubr::do_FeaturePlot() also accepts a vector of the identities to plot, as long as they are part of levels(seurat_object). This can be achieved by using the idents.highlight instead. SCpubr::do_FeaturePlot(sample, idents.highlight = levels(sample)[!(levels(sample) %in% c(&quot;2&quot;, &quot;5&quot;, &quot;8&quot;))], features = c(&quot;CD14&quot;), plot.title = &quot;My very important features&quot;) Figure 5.8: SCpubr FeaturePlot, masking cells from clusters 2, 5 and 8 using idents.highlight 5.3 Splitting the FeaturePlot by a variable In some cases, we want to visualize a given feature, let’s say, the expression of LYN across another variable, for instance seurat_clusters. This can be achieved easily in Seurat by using the split.by parameter: Seurat::FeaturePlot(sample, features = &quot;LYN&quot;, split.by = &quot;seurat_clusters&quot;) Figure 5.9: Seurat FeaturePlot split by clusters. Apart from the general aesthetic discrepancies mentioned before, there are two main aspects missing. First, is the overall layout of the UMAP embedding. Being able to correctly locate the clusters is really important. Secondly, knowing that, by default, the color scale is shared across all the plots (achieved by using keep.scale = \"feature\"), we would like to know up to which value this color scale reaches. In this two aspects is where SCpubr::do_FeaturePlot() delves into: SCpubr::do_FeaturePlot(sample, features = &quot;LYN&quot;, split.by = &quot;seurat_clusters&quot;) Figure 5.10: SCpubr FeaturePlot split by clusters. This way, we are able to achieve a better understandable plot. Please note that this has been implemented for keep.scale = \"feature\". Providing other options is not advisable. Furthermore, we can query multiple features, them being stacked by the different entities in split.by. The number of columns is predetermined to the number of entities and can not be modified. In this example, we provide each of the three possible examples of features: LYN is a gene located in the rownames of the count matrix (`rownames(sample)``). nCount_RNA is a metadata variable located in colnames(sample@meta.data). PC_1 is a column of a dimensional reduction embedding, located in colnames(sample@reductions[[\"pca\"]][[]]) SCpubr::do_FeaturePlot(sample, features = c(&quot;LYN&quot;, &quot;nCount_RNA&quot;, &quot;PC_1&quot;), split.by = &quot;seurat_clusters&quot;) Figure 5.11: SCpubr FeaturePlot split by clusters using multiple features. With SCpubr::FeaturePlot() we can even subset the previous plot to any identities in split.by we are particularly interested in. The color scale also limits itself to contain only the values in the selected identities. This can be achieved by provided a vector with the identities to split.by.idents parameter. SCpubr::do_FeaturePlot(sample, features = c(&quot;LYN&quot;, &quot;nCount_RNA&quot;, &quot;PC_1&quot;), split.by = &quot;seurat_clusters&quot;, split.by.idents = c(&quot;2&quot;, &quot;5&quot;, &quot;7&quot;)) Figure 5.12: SCpubr FeaturePlot split by clusters using multiple features and selected identities. "],["nebulosaplots.html", "Chapter 6 NebulosaPlots", " Chapter 6 NebulosaPlots This plot comes straight from the Nebulosa package. For more information, here is their vignette. In short, it computes a “density” of whether the surrounding cells (in the UMAP embedding) also express the variable that you provide to the function, same variables that one could feed to Seurat::FeaturePlot(). This is how their default plot looks like: Nebulosa::plot_density(sample, &quot;CD14&quot;) Figure 6.1: Nebulosa plot This way, not only we do know which clusters are enriched in CD14, we also know the regions of it with the hightest density of cells expressing it. Minor modifications, on the line of the rest of plots, are applied in SCpubr: SCpubr::do_NebulosaPlot(sample, features = &quot;CD14&quot;) Figure 6.2: SCpubr Nebulosa plot. Then, this type visualization becomes a natural partner to `Seurat::FeaturePlot()’ as not only we are able to visualize the expression of a variable, but also query the density of the surrounding cells. Here is an example: SCpubr::do_FeaturePlot(sample, features = &quot;CD14&quot;) | SCpubr::do_NebulosaPlot(sample, features = &quot;CD14&quot;) Figure 6.3: SCpubr FeaturePlot and NebulosaPlot. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page’s new location, or use the table of contents to find the page you are looking for. "]]
