[["index.html", "SCpubr - Complete reference Chapter 1 Aim of the package", " SCpubr - Complete reference Enrique Blanco Carmona 2022-02-16 Chapter 1 Aim of the package This package aims to provide a streamlined way of generating publication ready figures for known single-cell visualizations. As subjective as the term “aesthetically pleasant” can be, this a set of theme modifications implemented across different plot types. This package also serves as a personal project, with future prospects of growth. Include figure here. "],["installation-guide.html", "Chapter 2 Installation guide", " Chapter 2 Installation guide This package can be installed using the following commands: # From CRAN: # Future sumission to CRAN. # From GitHub. if(!requireNamespace(&quot;devtools&quot;, quietly = T)){ install.packages(&quot;devtools&quot;) # If not installed. } devtools::install_github(&quot;enblacar/SCpubr&quot;) Further packages are needed in order to run the different functions: colortools dplyr ggbeeswarm ggplot2 ggpubr Matrix Nebulosa patchwork pbapply purrr rlang scales Seurat stringr tidyr viridis All packages can be installed using the following commands: # Install CRAN packages. cran_packages &lt;- c(&quot;colortools&quot;, &quot;dplyr&quot;, &quot;ggbeeswarm&quot;, &quot;ggplot2&quot;, &quot;ggpubr&quot;, &quot;Matrix&quot;, &quot;patchwork&quot;, &quot;purrr&quot;, &quot;rlang&quot;, &quot;scales&quot;, &quot;Seurat&quot;, &quot;stringr&quot;, &quot;tidyr&quot;, &quot;viridis&quot;) install.packages(cran_packages) # Install bioconductor packages. bioconductor_packages &lt;- c(&quot;Nebulosa&quot;) if (!require(&quot;BiocManager&quot;, quietly = TRUE)) install.packages(&quot;BiocManager&quot;) BiocManager::install(bioconductor_packages) If interested in running only a subset of functions, SCpubr::state_dependencies() outputs the different packages and their sources needed for each of the functions. # Will return the package dependencies for all functions. SCpubr::state_dependencies() # Will return the package dependencies for selected functions. SCpubr::state_dependencies(func_name = c(&quot;do_DimPlot&quot;, &quot;do_Feature_Plot&quot;)) # Will return the package dependencies of a single function. SCpubr::state_dependencies(func_name = &quot;do_DimPlot&quot;) "],["dataset.html", "Chapter 3 Dataset", " Chapter 3 Dataset Through this manual we are going to use a publicly available dataset containing 10K raw cells. The following code is used to generate a Seurat object ready for plotting. counts_path &lt;- &quot;path_to_count_matrix&quot; # Path count matrix. counts &lt;- Seurat::Read10X(counts_path) # Create Seurat object. sample &lt;- Seurat::CreateSeuratObject(counts = counts, project = &quot;10K_pbmc&quot;) # Compute percentage of mithochondrial RNA. sample &lt;- Seurat::PercentageFeatureSet(sample, pattern = &quot;^MT-&quot;, col.name = &quot;percent.mt&quot;) # Compute QC. mask1 &lt;- sample$nCount_RNA &gt;= 1000 mask2 &lt;- sample$nFeature_RNA &gt;= 500 mask3 &lt;- sample$percent.mt &lt;= 20 mask &lt;- mask1 &amp; mask2 &amp; mask3 sample &lt;- sample[, mask] # Normalize. sample &lt;- Seurat::SCTransform(sample) # Dimensional reduction. sample &lt;- Seurat::RunPCA(sample) sample &lt;- Seurat::RunUMAP(sample, dims = 1:30) # Find clusters. sample &lt;- Seurat::FindNeighbors(sample, dims = 1:30) sample &lt;- Seurat::FindClusters(sample, resolution = 0.2) "],["dim-plots.html", "Chapter 4 Dim plots 4.1 Regular DimPlots 4.2 Highlighting cells 4.3 Splitting by a category", " Chapter 4 Dim plots DimPlots are, probably, one of the most iconic visualizations from Seurat. It allows the user to visualize the cells in a dimensional reduction embedding such as PCA or UMAP. The cells can be, then, colored by any desired groups. In short, this visualization allows the user to plot any kind of categorical data onto the cells in the dimesional reduction embedding. This is achieved by using Seurat::DimPlot() funtion: Seurat::DimPlot(sample) Figure 4.1: Default DimPlot. Overall, this is a pretty neat visualization, but there are quite some changes that one would like to implement. For instance, shuffling the cells so that there is no overlap of cells just due to the cluster names. Seurat::DimPlot(sample, shuffle = T) Figure 4.2: DimPlot with the cells shuffled. Furthermore, one would think about the need of the axes. If, by consensus, UMAPs are shown plotting the first UMAP component on the X axis and the second on the Y axis, then showing them becomes redundant, specially when one can not truly rely on the numbers shown by the scales. Seurat::DimPlot(sample, shuffle = T) + Seurat::NoAxes() Figure 4.3: DimPlot without axes. Right now, we can observe a couple of things. First, is that the dot size is rather small. Let’s set it to 0.5. Seurat::DimPlot(sample, shuffle = T, pt.size = 0.5) + Seurat::NoAxes() Figure 4.4: DimPlot with increased dot size. Still, the legend seems rather small. Let’s increase it’s font size and set it to bold so that it can better read. Seurat::DimPlot(sample, shuffle = T, pt.size = 0.5) + Seurat::NoAxes() + ggplot2::theme(legend.text = ggplot2::element_text(size = 16, face = &quot;bold&quot;), legend.title = ggplot2::element_text(size = 16, face = &quot;bold&quot;)) Figure 4.5: DimPlot with increased font size. We would also like to add a title to our plot, to best describe it. Seurat::DimPlot(sample, shuffle = T, pt.size = 0.5) + Seurat::NoAxes() + ggplot2::ggtitle(&quot;My awesome SC dataset&quot;) + ggplot2::theme(legend.text = ggplot2::element_text(size = 16, face = &quot;bold&quot;), legend.title = ggplot2::element_text(size = 16, face = &quot;bold&quot;)) Figure 4.6: DimPlot with title. And, naturally, we would like to increase the font size of the title and put it in bold and centered. Seurat::DimPlot(sample, shuffle = T, pt.size = 0.5) + Seurat::NoAxes() + ggplot2::ggtitle(&quot;My awesome SC dataset&quot;) + ggplot2::theme(plot.title = ggplot2::element_text(size = 20, face = &quot;bold&quot;, hjust = 0.5), legend.text = ggplot2::element_text(size = 16, face = &quot;bold&quot;), legend.title = ggplot2::element_text(size = 16, face = &quot;bold&quot;)) Figure 4.7: DimPlot with bigger and bold title. Now, we would like to modify the color palette. This palette has too bright colors, and we want something more toned down. num_clusters &lt;- length(unique(sample$seurat_clusters)) color_scale &lt;- colortools::setColors(&quot;#457b9d&quot;, num_clusters) names(color_scale) &lt;- sort(unique(sample$seurat_clusters)) Seurat::DimPlot(sample, shuffle = T, pt.size = 0.5, cols = color_scale) + Seurat::NoAxes() + ggplot2::ggtitle(&quot;My awesome SC dataset&quot;) + ggplot2::theme(plot.title = ggplot2::element_text(size = 20, face = &quot;bold&quot;, hjust = 0.5), legend.text = ggplot2::element_text(size = 16, face = &quot;bold&quot;), legend.title = ggplot2::element_text(size = 16, face = &quot;bold&quot;)) Figure 4.8: DimPlot with custom color scale. The legend on the right side seems off, what if we were to have long cluster names? It would inevitable take a lot of space from the actual plot. Let’s better put it on the bottom. num_clusters &lt;- length(unique(sample$seurat_clusters)) color_scale &lt;- colortools::setColors(&quot;#457b9d&quot;, num_clusters) names(color_scale) &lt;- sort(unique(sample$seurat_clusters)) Seurat::DimPlot(sample, shuffle = T, pt.size = 0.5, cols = color_scale) + ggpubr::theme_pubr(legend = &quot;bottom&quot;) + Seurat::NoAxes() + ggplot2::ggtitle(&quot;My awesome SC dataset&quot;) + ggplot2::theme(plot.title = ggplot2::element_text(size = 20, face = &quot;bold&quot;, hjust = 0.5), legend.text = ggplot2::element_text(size = 16, face = &quot;bold&quot;), legend.title = ggplot2::element_text(size = 16, face = &quot;bold&quot;)) Figure 4.9: DimPlot with legend at the bottom. Still, there are too many columns in the legend. Let’s rearrange it into four columns. num_clusters &lt;- length(unique(sample$seurat_clusters)) color_scale &lt;- colortools::setColors(&quot;#457b9d&quot;, num_clusters) names(color_scale) &lt;- sort(unique(sample$seurat_clusters)) Seurat::DimPlot(sample, shuffle = T, pt.size = 0.5, cols = color_scale) + ggpubr::theme_pubr(legend = &quot;bottom&quot;) + Seurat::NoAxes() + ggplot2::ggtitle(&quot;My awesome SC dataset&quot;) + ggplot2::theme(plot.title = ggplot2::element_text(size = 20, face = &quot;bold&quot;, hjust = 0.5), legend.text = ggplot2::element_text(size = 16, face = &quot;bold&quot;), legend.title = ggplot2::element_text(size = 16, face = &quot;bold&quot;)) + ggplot2::guides(color = ggplot2::guide_legend(ncol = 4, byrow = F)) Figure 4.10: DimPlot with legend at the bottom in four columns. But now the legend icon sizes are too small! We have to fix this. num_clusters &lt;- length(unique(sample$seurat_clusters)) color_scale &lt;- colortools::setColors(&quot;#457b9d&quot;, num_clusters) names(color_scale) &lt;- sort(unique(sample$seurat_clusters)) Seurat::DimPlot(sample, shuffle = T, pt.size = 0.5, cols = color_scale) + ggpubr::theme_pubr(legend = &quot;bottom&quot;) + Seurat::NoAxes() + ggplot2::ggtitle(&quot;My awesome SC dataset&quot;) + ggplot2::theme(plot.title = ggplot2::element_text(size = 20, face = &quot;bold&quot;, hjust = 0.5), legend.text = ggplot2::element_text(size = 16, face = &quot;bold&quot;), legend.title = ggplot2::element_text(size = 16, face = &quot;bold&quot;)) + ggplot2::guides(color = ggplot2::guide_legend(ncol = 4, byrow = F, override.aes = list(size = 4))) Figure 4.11: DimPlot with legend at the bottom in four columns. As of now, this plot looks much better and polished than the default counterpart. This, is the setting ground for SCpubr::do_DimPlot(). 4.1 Regular DimPlots This is the default output from SCpubr::do_DimPlot(). SCpubr::do_DimPlot(sample) Figure 4.12: SCpubr DimPlot. We can add a title with the plot.title parameter. SCpubr::do_DimPlot(sample, plot.title = &quot;My awesome SC data set&quot;) Figure 4.13: SCpubr DimPlot with title. We can change the legend location and number of columns with legend.position and legend.ncol. SCpubr::do_DimPlot(sample, plot.title = &quot;My awesome SC data set&quot;, legend.position = &quot;left&quot;, legend.ncol = 4) Figure 4.14: SCpubr DimPlot with legend to the left. 4.2 Highlighting cells One of the nice features of Seurat::DimPlot() is the possibility of highlighting a certain group of cells in the DimPlot. This is achieved by using the cells.highligh parameter. This is how the default plot looks like. # Select 1000 random cells out of clusters 1, 5 and 7. cells.use &lt;- sample(colnames(sample[, sample$seurat_clusters %in% c(&quot;1&quot;, &quot;5&quot;, &quot;7&quot;)]), 1000) Seurat::DimPlot(sample, cells.highlight = cells.use) Figure 4.15: Seurat DimPlot highlighting cells. This is how SCpubr returns this plot. For this, the same parameter has to be set up. # Select 1000 random cells out of clusters 1, 5 and 7. cells.use &lt;- sample(colnames(sample[, sample$seurat_clusters %in% c(&quot;1&quot;, &quot;5&quot;, &quot;7&quot;)]), 1000) SCpubr::do_DimPlot(sample, cells.highlight = cells.use) Figure 4.16: SCpubr DimPlot highlighting cells. By default, the size of all cells in SCpubr::do_DimPlot() is the same. However, the size of the highlighted dots can be modified with the parameter sizes.highlight from Seurat. # Select 1000 random cells out of clusters 1, 5 and 7. cells.use &lt;- sample(colnames(sample[, sample$seurat_clusters %in% c(&quot;1&quot;, &quot;5&quot;, &quot;7&quot;)]), 1000) SCpubr::do_DimPlot(sample, cells.highlight = cells.use, sizes.highlight = 2) Figure 4.17: SCpubr DimPlot highlighting cells bigger dot size. 4.3 Splitting by a category Another useful paramter of Seurat::DimPlot is split.by, which allows you to split your DimPlot into multiple panels, each one containing a different unique value of the metadata variable you have provided to the argument. One can understand this as using the group.by parameter and then splitting the resulting DimPlot into different panels. In this example, we are going to use the different clusters as an example This is how it looks by default: # Using ncol = 5 to maintain some of the proportions. Seurat::DimPlot(sample, split.by = &quot;seurat_clusters&quot;, ncol = 5) Figure 4.18: Seurat DimPlot using split.by. As can be observed, this plots accomplish the task of separating the cells into each panel, but the approach followed actually makes interpretation difficult. Clusters such as Cluster 9, with fewer cells, tell pretty much nothing. Not knowing how the original UMAP looked like is a major downside of this approach. This is where SCpubr focus. Instead of using Seurat’s split.by parameter, it generates as many plots as unique values in the metadata to split the plot by, but uses cells.highlight instead, which keeps the rest of cells greyed out. This is how it looks: # Using ncol = 5 to maintain some of the proportions. # Using legend = F to remove unwanted repeated legends. SCpubr::do_DimPlot(sample, split.by = &quot;seurat_clusters&quot;, ncol = 5, legend = F) Figure 4.19: SCpubr DimPlot using split.by. This way, we can see that clusters such as Cluster 7 are way more disperse than the rest, accounting not only for standalone groups of cells but also blending in other bigger clusters. Actually, the user might want to change the color of the highlighted cells in this split DimPlot. This is achieved by using colors.split parameter and providing either a color name recognized by ggplot2 or (recommended) a HEX code. # Using ncol = 5 to maintain some of the proportions. # Using legend = F to remove unwanted repeated legends. SCpubr::do_DimPlot(sample, split.by = &quot;seurat_clusters&quot;, ncol = 5, legend = F, colors.split = &quot;black&quot;) Figure 4.20: SCpubr DimPlot using split.by with a changed color Furthermore, one might also want to color each cluster by the original color. This can be achieved by using the argument colorss.split, either providing a named vector of each cluster (or metadata variable unique value) as names and color hex codes as values or TRUE, thus resorting to the default SCpubr categorical coloring. # Using ncol = 5 to maintain some of the proportions. # Using legend = F to remove unwanted repeated legends. SCpubr::do_DimPlot(sample, split.by = &quot;seurat_clusters&quot;, ncol = 5, legend = F, colors.split = TRUE) Figure 4.21: SCpubr DimPlot using split.by with default SCpubr colors "],["feature-plots.html", "Chapter 5 Feature plots 5.1 Multiple features 5.2 Working with subsets of cells 5.3 Splitting the FeaturePlot by a variable 5.4 Modify color maps", " Chapter 5 Feature plots Another broadly used function in Seurat is Seurat::FeaturePlot(). It is basically the counterpart of Seurat::DimPlot() which instead of coloring the cells based on a categorical color scale, it uses a continuous one, according to a variable provided by the user. This can range from gene expression, to metadata variables such as the number of genes, or even values such as PC_1. This is how it looks, plotting the number of UMIs: Seurat::FeaturePlot(sample, features = &quot;nCount_RNA&quot;) Figure 5.1: Seurat FeaturePlot First thing that stands out, it that the color scale could be changed to one with two very opposite ends, so that identifying regions with low and high UMIs become an easier task. Apart from that, we want apply the same treatment as in do_DimPlot() section. Seurat::FeaturePlot(sample, features = &quot;nCount_RNA&quot;) + Seurat::NoAxes() + viridis::scale_color_viridis() Figure 5.2: Seurat FeaturePlot, with new color scale and general modifications This way, we can observe that most of the clusters have a really similar number of UMIs, despite selected ones which have up to 4 times more. These could very well be doublets. This is SCpubr::do_FeaturePlot() variation: SCpubr::do_FeaturePlot(sample, features = &quot;nCount_RNA&quot;, plot.title = &quot;Number of UMIs&quot;) Figure 5.3: SCpubr FeaturePlot, with minor modifications By default, SCpubr enlarges the dots a bit and makes the legend bold, to better stand out. 5.1 Multiple features SCpubr::do_FeaturePlot() can tackle multiple queries at the same time. Plots can be rearranged as desired with ncol parameter: SCpubr::do_FeaturePlot(sample, features = c(&quot;nCount_RNA&quot;, &quot;nFeature_RNA&quot;, &quot;percent.mt&quot;, &quot;CD14&quot;), plot.title = &quot;My very important features&quot;, ncol = 2) Figure 5.4: SCpubr FeaturePlot, with 4 features and 2 columns With multiple queries, using plot.title parameter actually adds an overall title. If one wants to modify the title of each plot independently, a more complex approach is needed, which requires more R expertise, using patchwork package. ((SCpubr::do_FeaturePlot(sample, features = &quot;nCount_RNA&quot;, plot.title = &quot;Plot A&quot;) | SCpubr::do_FeaturePlot(sample, features = &quot;nFeature_RNA&quot;, plot.title = &quot;Plot B&quot;)) / (SCpubr::do_FeaturePlot(sample, features = &quot;percent.mt&quot;, plot.title = &quot;Plot C&quot;) | SCpubr::do_FeaturePlot(sample, features = &quot;CD14&quot;, plot.title = &quot;Plot D&quot;))) + patchwork::plot_annotation(title = &quot;My very important features&quot;, theme = ggplot2::theme(plot.title = ggplot2::element_text(size = 18, face = &quot;bold&quot;, hjust = 0.5))) Figure 5.5: SCpubr FeaturePlot, with individual modified titles 5.2 Working with subsets of cells One of the things that can be misleading, is that it could be the case that a very specific subset of cells are driving the ends of the color scales. Let’s say that we have identified that clusters 2, 5, and 8 are responsible of this behavior. We would like to have plot the values without taking those cells into consideration. The very first thing that comes to mind is, indeed, removing the cells completely, resulting in the following: cells.plot &lt;- colnames(sample[, !(sample$seurat_clusters %in% c(&quot;2&quot;, &quot;5&quot;, &quot;8&quot;))]) SCpubr::do_FeaturePlot(sample[, cells.plot], features = c(&quot;CD14&quot;), plot.title = &quot;My very important features&quot;) Figure 5.6: SCpubr FeaturePlot, removing cells from clusters 2, 5 and 8 However, this falls back to the same problem as with Seurat::DimPlot with the split.by parameter. We lose the overall context of where the cells are. This is taken care by in SCpubr::do_FeaturePlot(), when using the cells.highlight parameter: cells.plot &lt;- colnames(sample[, !(sample$seurat_clusters %in% c(&quot;2&quot;, &quot;5&quot;, &quot;8&quot;))]) SCpubr::do_FeaturePlot(sample, cells.highlight = cells.plot, features = c(&quot;CD14&quot;), plot.title = &quot;My very important features&quot;) Figure 5.7: SCpubr FeaturePlot, masking cells from clusters 2, 5 and 8 This way, by adding the cells back and modifying the legend, we accomplish the desired effect. Furthermore, SCpubr::do_FeaturePlot() also accepts a vector of the identities to plot, as long as they are part of levels(seurat_object). This can be achieved by using the idents.highlight instead. SCpubr::do_FeaturePlot(sample, idents.highlight = levels(sample)[!(levels(sample) %in% c(&quot;2&quot;, &quot;5&quot;, &quot;8&quot;))], features = c(&quot;CD14&quot;), plot.title = &quot;My very important features&quot;) Figure 5.8: SCpubr FeaturePlot, masking cells from clusters 2, 5 and 8 using idents.highlight 5.3 Splitting the FeaturePlot by a variable In some cases, we want to visualize a given feature, let’s say, the expression of LYN across another variable, for instance seurat_clusters. This can be achieved easily in Seurat by using the split.by parameter: Seurat::FeaturePlot(sample, features = &quot;LYN&quot;, split.by = &quot;seurat_clusters&quot;) Figure 5.9: Seurat FeaturePlot split by clusters. Apart from the general aesthetic discrepancies mentioned before, there are two main aspects missing. First, is the overall layout of the UMAP embedding. Being able to correctly locate the clusters is really important. Secondly, knowing that, by default, the color scale is shared across all the plots (achieved by using keep.scale = \"feature\"), we would like to know up to which value this color scale reaches. In this two aspects is where SCpubr::do_FeaturePlot() delves into: SCpubr::do_FeaturePlot(sample, features = &quot;LYN&quot;, split.by = &quot;seurat_clusters&quot;) Figure 5.10: SCpubr FeaturePlot split by clusters. This way, we are able to achieve a better understandable plot. Please note that this has been implemented for keep.scale = \"feature\". Providing other options is not advisable. Furthermore, we can query multiple features, them being stacked by the different entities in split.by. The number of columns is predetermined to the number of entities and can not be modified. In this example, we provide each of the three possible examples of features: LYN is a gene located in the rownames of the count matrix (`rownames(sample)``). nCount_RNA is a metadata variable located in colnames(sample@meta.data). PC_1 is a column of a dimensional reduction embedding, located in colnames(sample@reductions[[\"pca\"]][[]]) SCpubr::do_FeaturePlot(sample, features = c(&quot;LYN&quot;, &quot;nCount_RNA&quot;, &quot;PC_1&quot;), split.by = &quot;seurat_clusters&quot;) Figure 5.11: SCpubr FeaturePlot split by clusters using multiple features. With SCpubr::do_FeaturePlot() we can even subset the previous plot to any identities in split.by we are particularly interested in. The color scale also limits itself to contain only the values in the selected identities. This can be achieved by provided a vector with the identities to split.by.idents parameter. SCpubr::do_FeaturePlot(sample, features = c(&quot;LYN&quot;, &quot;nCount_RNA&quot;, &quot;PC_1&quot;), split.by = &quot;seurat_clusters&quot;, split.by.idents = c(&quot;2&quot;, &quot;5&quot;, &quot;7&quot;)) Figure 5.12: SCpubr FeaturePlot split by clusters using multiple features and selected identities. 5.4 Modify color maps It is possible in SCpubr::do_FeaturePlot() to also change the color map of the plot to one of the eight possible ones defined in viridis. This is achieved by using viridis_color_map parameter and the color map name or code (capital letter). Options are: A - magma color map. B - inferno color map. C - plasma color map. D - viridis color map. E - cividis color map. F - rocket color map. G - mako color map. H - turbo color map. p1 &lt;- SCpubr::do_FeaturePlot(sample = sample, features = &quot;CD14&quot;, viridis_color_map = &quot;A&quot;, plot.title = &quot;Magma&quot;) p2 &lt;- SCpubr::do_FeaturePlot(sample = sample, features = &quot;CD14&quot;, viridis_color_map = &quot;B&quot;, plot.title = &quot;Inferno&quot;) p3 &lt;- SCpubr::do_FeaturePlot(sample = sample, features = &quot;CD14&quot;, viridis_color_map = &quot;C&quot;, plot.title = &quot;Plasma&quot;) p4 &lt;- SCpubr::do_FeaturePlot(sample = sample, features = &quot;CD14&quot;, viridis_color_map = &quot;D&quot;, plot.title = &quot;Viridis&quot;) p5 &lt;- SCpubr::do_FeaturePlot(sample = sample, features = &quot;CD14&quot;, viridis_color_map = &quot;E&quot;, plot.title = &quot;Cividis&quot;) p6 &lt;- SCpubr::do_FeaturePlot(sample = sample, features = &quot;CD14&quot;, viridis_color_map = &quot;F&quot;, plot.title = &quot;Rocket&quot;) p7 &lt;- SCpubr::do_FeaturePlot(sample = sample, features = &quot;CD14&quot;, viridis_color_map = &quot;G&quot;, plot.title = &quot;Mako&quot;) p8 &lt;- SCpubr::do_FeaturePlot(sample = sample, features = &quot;CD14&quot;, viridis_color_map = &quot;H&quot;, plot.title = &quot;Turbo&quot;) #&gt; Warning in check_viridis_color_map(viridis_color_map = viridis_color_map, : The #&gt; selected option is not the most adequate for a continuous color scale. p &lt;- patchwork::wrap_plots(list(p1, p2, p3, p4, p5, p6, p7, p8), ncol = 2, byrow = TRUE) p Figure 5.13: SCpubr FeaturePlot modifying viridis color maps. Here, we do not recommend the use of turbo with Feature plots, as this continuous scale goes through many different colors and, therefore, makes it harder for interpretation. "],["nebulosa-plots.html", "Chapter 6 Nebulosa plots 6.1 Modify color maps", " Chapter 6 Nebulosa plots This plot comes straight from the Nebulosa package. For more information, here is their vignette. In short, it computes a “density” of whether the surrounding cells (in the UMAP embedding) also express the variable that you provide to the function, same variables that one could feed to Seurat::FeaturePlot(). This is how their default plot looks like: Nebulosa::plot_density(sample, &quot;CD14&quot;) Figure 6.1: Nebulosa plot This way, not only we do know which clusters are enriched in CD14, we also know the regions of it with the hightest density of cells expressing it. Minor modifications, on the line of the rest of plots, are applied in SCpubr: SCpubr::do_NebulosaPlot(sample, features = &quot;CD14&quot;) Figure 6.2: SCpubr Nebulosa plot. Then, this type visualization becomes a natural partner to `Seurat::FeaturePlot()’ as not only we are able to visualize the expression of a variable, but also query the density of the surrounding cells. Here is an example: SCpubr::do_FeaturePlot(sample, features = &quot;CD14&quot;) | SCpubr::do_NebulosaPlot(sample, features = &quot;CD14&quot;) Figure 6.3: SCpubr FeaturePlot and NebulosaPlot. Nebulosa package also offers the option to query multiple features at the same time: SCpubr::do_NebulosaPlot(sample, features = c(&quot;CD14&quot;, &quot;CD8A&quot;)) Figure 6.4: SCpubr Nebulosa plot with multiple features. But, more intriguingly, it can also compute the joint density of the two features. This is achieved by parsing joint = TRUE. SCpubr::do_NebulosaPlot(sample, features = c(&quot;CD14&quot;, &quot;CD8A&quot;), joint = TRUE) Figure 6.5: SCpubr Nebulosa plot with joint density If we were interested in retrieving only the joint density plot, we can accomplish it as: p &lt;- SCpubr::do_NebulosaPlot(sample, features = c(&quot;CD14&quot;, &quot;CD8A&quot;), joint = TRUE, combine = F) p[[3]] Figure 6.6: SCpubr Nebulosa plot with joint density, selecting only the last plot 6.1 Modify color maps Same as in SCpubr::do_FeaturePlot(), it is also change the color map of the plot to one of the eight possible ones defined in viridis. This is achieved by using viridis_color_map parameter and the color map name or code (capital letter). Options are: A - magma color map. B - inferno color map. C - plasma color map. D - viridis color map. E - cividis color map. F - rocket color map. G - mako color map. H - turbo color map. p1 &lt;- SCpubr::do_NebulosaPlot(sample = sample, features = &quot;CD8A&quot;, viridis_color_map = &quot;A&quot;, plot.title = &quot;Magma&quot;) p2 &lt;- SCpubr::do_NebulosaPlot(sample = sample, features = &quot;CD8A&quot;, viridis_color_map = &quot;B&quot;, plot.title = &quot;Inferno&quot;) p3 &lt;- SCpubr::do_NebulosaPlot(sample = sample, features = &quot;CD8A&quot;, viridis_color_map = &quot;C&quot;, plot.title = &quot;Plasma&quot;) p4 &lt;- SCpubr::do_NebulosaPlot(sample = sample, features = &quot;CD8A&quot;, viridis_color_map = &quot;D&quot;, plot.title = &quot;Viridis&quot;) p5 &lt;- SCpubr::do_NebulosaPlot(sample = sample, features = &quot;CD8A&quot;, viridis_color_map = &quot;E&quot;, plot.title = &quot;Cividis&quot;) p6 &lt;- SCpubr::do_NebulosaPlot(sample = sample, features = &quot;CD8A&quot;, viridis_color_map = &quot;F&quot;, plot.title = &quot;Rocket&quot;) p7 &lt;- SCpubr::do_NebulosaPlot(sample = sample, features = &quot;CD8A&quot;, viridis_color_map = &quot;G&quot;, plot.title = &quot;Mako&quot;) p8 &lt;- SCpubr::do_NebulosaPlot(sample = sample, features = &quot;CD8A&quot;, viridis_color_map = &quot;H&quot;, plot.title = &quot;Turbo&quot;) #&gt; Warning in check_viridis_color_map(viridis_color_map = viridis_color_map, : The #&gt; selected option is not the most adequate for a continuous color scale. p &lt;- patchwork::wrap_plots(list(p1, p2, p3, p4, p5, p6, p7, p8), ncol = 2, byrow = TRUE) p Figure 6.7: SCpubr Nebulosa plot modifying viridis color maps. "],["bee-swarm-plots.html", "Chapter 7 Bee Swarm plots 7.1 Using categorical variables 7.2 Using continuous variables 7.3 Modify color maps for continuous variables", " Chapter 7 Bee Swarm plots This one is a very interesting plot. It stems from the idea that we can order (rank) the cells in a given variable. This variable has to be a continuous variable, for a better representation. The order goes from lowest to maximum value. Then, the cells are grouped into any other variable of interest and displayed in a scatter plot fashion. This is achieved by using the ggbeeswarm package. The idea of using the ggbeeswarm::geom_quasirandom() geometry provided by this package and implement it for single-cell analyses came from this tutorial from the Broad Institute. 7.1 Using categorical variables Let’s say we want to focus on how much each cluster is driven by the PC_1 and PC_2. The first thought is to just use SCpubr::do_Dimplot() to plot the PCA embedding instead of the UMAP. We also query PC_3 and PC_4 to have a not-so-clear example. p1 &lt;- SCpubr::do_DimPlot(sample, reduction = &quot;pca&quot;, label = T, legend = F, dims = c(1, 2)) p2 &lt;- SCpubr::do_DimPlot(sample, reduction = &quot;pca&quot;, label = T, legend = F, dims = c(3, 4)) p1 | p2 Figure 7.1: Plotting PCA embeddings with SCpubr::do_DimPlot() With this, we get right away a decent overview. Clusters 0, 5, 7 and 8 separate on PC_1 from the rest. However, in many cases this will not be clear, such as the image on the right. This is where Bee Swarm plots come in handy. This is implemented in SCpubr::do_BeeSwarmPlot(). This function needs the user to provide: - The variable to rank to feature_to_rank. - The groups to divide the plot into to group.by. - Whether the output should be colored with a categorical or continuous scale, with continuous_feature. p1 &lt;- SCpubr::do_DimPlot(sample, reduction = &quot;pca&quot;, label = T, legend = F, dims = c(1, 2)) p2 &lt;- SCpubr::do_BeeSwarmPlot(sample = sample, feature_to_rank = &quot;PC_1&quot;, group.by = &quot;seurat_clusters&quot;, continuous_feature = F) p3 &lt;- SCpubr::do_DimPlot(sample, reduction = &quot;pca&quot;, label = T, legend = F, dims = c(3, 4)) p4 &lt;- SCpubr::do_BeeSwarmPlot(sample = sample, feature_to_rank = &quot;PC_4&quot;, group.by = &quot;seurat_clusters&quot;, continuous_feature = F) (p1 | p2) / (p3 | p4) Figure 7.2: SCpubr Bee Swarm plots with categorical variables. Here, we have selected PC_1 and PC_4. We can observe how the X axis of the Bee Swarm plot displays the ordering (rank) of all of the cells across the selected feature. Focusing on PC_1, we can see that cluster 0 is completely shifted to the right on PC_1, with is nicely displayed in the Bee Swarm plot by having all of the cells also ranked high (the higher the rank, the bigger the “value” of the feature to rank, in this case, the PC_1 value). In the case of PC_4, the Bee Swarm plot nicely shows which clusters lay on the upper, lower or middle part of the PC_4. A very important thing to note in these kind of plots is that no cells will have the same rank. This is, imagine a scenario like PC_4, but we artificially remove clusters 0, 3, 5, 7, 8, 9, leaving only those forming a “straight line” in PC_4. The nature of this plot will also separate the remaining clusters: # Clusters to exclude. clusters_exclude &lt;- c(&quot;0&quot;, &quot;3&quot;, &quot;5&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;) # Keep the original coloring. cols.use &lt;- colortools::setColors(&quot;steelblue&quot;, length(levels(sample))) names(cols.use) &lt;- levels(sample) p1 &lt;- SCpubr::do_DimPlot(sample[, !(sample$seurat_clusters %in% clusters_exclude)], reduction = &quot;pca&quot;, label = T, legend = F, dims = c(3, 4), colors.use = cols.use) p2 &lt;- SCpubr::do_BeeSwarmPlot(sample = sample[, !(sample$seurat_clusters %in% clusters_exclude)], feature_to_rank = &quot;PC_4&quot;, group.by = &quot;seurat_clusters&quot;, continuous_feature = F, colors.use = cols.use) p1 | p2 Figure 7.3: SCpubr Bee Swarm plots with similar values. See, we still clearly see two groups, formed by clusters 1 and 2, and clusters 4 and 6. We could even remove clusters 1 and 2 and still see a similar effect. # Clusters to exclude. clusters_exclude &lt;- c(&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;5&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;) # Keep the original coloring. cols.use &lt;- colortools::setColors(&quot;steelblue&quot;, length(levels(sample))) names(cols.use) &lt;- levels(sample) p1 &lt;- SCpubr::do_DimPlot(sample[, !(sample$seurat_clusters %in% clusters_exclude)], reduction = &quot;pca&quot;, label = T, legend = F, dims = c(3, 4), colors.use = cols.use) p2 &lt;- SCpubr::do_BeeSwarmPlot(sample = sample[, !(sample$seurat_clusters %in% clusters_exclude)], feature_to_rank = &quot;PC_4&quot;, group.by = &quot;seurat_clusters&quot;, continuous_feature = F, colors.use = cols.use) p1 | p2 Figure 7.4: SCpubr Bee Swarm plots with almost identical values. As can be seen here, both clusters now span all X axis. The cells have still ranked, therefore showing a cloud of dots. With this, we would just want that, as with any data visualization technique, each plot comes with a set of benefits and caveats. This visualization suffers from trying to plot highly similar values. Therefore, it is key to understand the nature of the variable you want to rank beforehand. 7.2 Using continuous variables There are also scenarios in which we want to rank the cells to a continuous variable, but instead of showing colors for each group (which is anyway depicted in the Y axis), we want to introduce a continuous color scale. This is specially interesting to assess enrichment of clusters towards a given set of features. # Set up list of a genes to compute enrichment. Let&#39;s use a monocyte signature. genes.use &lt;- c(&quot;CD14&quot;, &quot;LYZ&quot;) # Compute enrichment and rename the output. sample &lt;- Seurat::AddModuleScore(sample, features = genes.use, name = &quot;Monocyte_signature&quot;) sample$Monocyte_signature &lt;- sample$Monocyte_signature1 sample$Monocyte_signature1 &lt;- NULL p1 &lt;- SCpubr::do_DimPlot(sample, label = T, legend = F) p2 &lt;- SCpubr::do_FeaturePlot(sample, features = &quot;Monocyte_signature&quot;) p3 &lt;- SCpubr::do_BeeSwarmPlot(sample, feature_to_rank = &quot;Monocyte_signature&quot;, group.by = &quot;seurat_clusters&quot;, continuous_feature = T) p1 | p2 | p3 Figure 7.5: Using continuous color scale in SCpubr::do_BeeSwarmPlot(). By using this combination of figures, we can also assess that the monocyte signature seems to be predominantly enriched in clusters 0 and 7. 7.3 Modify color maps for continuous variables Same as in SCpubr::do_FeaturePlot(), it is also change the color map of the plot to one of the eight possible ones defined in viridis. This is achieved by using viridis_color_map parameter and the color map name or code (capital letter). Options are: A - magma color map. B - inferno color map. C - plasma color map. D - viridis color map. E - cividis color map. F - rocket color map. G - mako color map. H - turbo color map. p1 &lt;- SCpubr::do_BeeSwarmPlot(sample = sample, feature_to_rank = &quot;Monocyte_signature&quot;, group.by = &quot;seurat_clusters&quot;, continuous_feature = TRUE, fontsize = 10, viridis_color_map = &quot;A&quot;, plot.title = &quot;Magma&quot;) p2 &lt;- SCpubr::do_BeeSwarmPlot(sample = sample, feature_to_rank = &quot;Monocyte_signature&quot;, group.by = &quot;seurat_clusters&quot;, continuous_feature = TRUE, fontsize = 10, viridis_color_map = &quot;B&quot;, plot.title = &quot;Inferno&quot;) p3 &lt;- SCpubr::do_BeeSwarmPlot(sample = sample, feature_to_rank = &quot;Monocyte_signature&quot;, group.by = &quot;seurat_clusters&quot;, continuous_feature = TRUE, fontsize = 10, viridis_color_map = &quot;C&quot;, plot.title = &quot;Plasma&quot;) p4 &lt;- SCpubr::do_BeeSwarmPlot(sample = sample, feature_to_rank = &quot;Monocyte_signature&quot;, group.by = &quot;seurat_clusters&quot;, continuous_feature = TRUE, fontsize = 10, viridis_color_map = &quot;D&quot;, plot.title = &quot;Viridis&quot;) p5 &lt;- SCpubr::do_BeeSwarmPlot(sample = sample, feature_to_rank = &quot;Monocyte_signature&quot;, group.by = &quot;seurat_clusters&quot;, continuous_feature = TRUE, fontsize = 10, viridis_color_map = &quot;E&quot;, plot.title = &quot;Cividis&quot;) p6 &lt;- SCpubr::do_BeeSwarmPlot(sample = sample, feature_to_rank = &quot;Monocyte_signature&quot;, group.by = &quot;seurat_clusters&quot;, continuous_feature = TRUE, fontsize = 10, viridis_color_map = &quot;F&quot;, plot.title = &quot;Rocket&quot;) p7 &lt;- SCpubr::do_BeeSwarmPlot(sample = sample, feature_to_rank = &quot;Monocyte_signature&quot;, group.by = &quot;seurat_clusters&quot;, continuous_feature = TRUE, fontsize = 10, viridis_color_map = &quot;G&quot;, plot.title = &quot;Mako&quot;) p8 &lt;- SCpubr::do_BeeSwarmPlot(sample = sample, feature_to_rank = &quot;Monocyte_signature&quot;, group.by = &quot;seurat_clusters&quot;, continuous_feature = TRUE, fontsize = 10, viridis_color_map = &quot;H&quot;, plot.title = &quot;Turbo&quot;) #&gt; Warning in check_viridis_color_map(viridis_color_map = viridis_color_map, : The #&gt; selected option is not the most adequate for a continuous color scale. p &lt;- patchwork::wrap_plots(list(p1, p2, p3, p4, p5, p6, p7, p8), ncol = 2, byrow = TRUE) p Figure 7.6: SCpubr Nebulosa plot modifying viridis color maps. "],["violin-plots.html", "Chapter 8 Violin plots 8.1 Violin plots as a means of QC", " Chapter 8 Violin plots Violin plots require very little description. They are a depiction of the distribution of a variable. It makes it ideal in order to show differential enrichment patterns alongside different groups. As such, it is also included in Seurat under Seurat::VlnPlot() function. The very first time a new user encounters this function is likely going to be when querying for different QC paramters, such as the number of UMIs, the number of genes or the percentage of mitochondrial RNA. This is how it looks for the number of UMIs: Seurat::VlnPlot(sample, features = &quot;nCount_RNA&quot;) Figure 8.1: Seurat’s violin plot. The one thing that really stands out here is, indeed, the extra dots that are being plotted alongside the violin plot. Since each dot represent a cell, it quickly becomes the dominant feature of the figure. One can play with the alpha of the dots to reduce their presence: p &lt;- Seurat::VlnPlot(sample, features = &quot;nCount_RNA&quot;) # &quot;Surgically&quot; add the alpha parameter in the ggplot2 object. p$layers[[2]]$aes_params$alpha &lt;- 0.05 p Figure 8.2: Seurat’s violin plot with transparent dots. But still, by making the dots almost invisible, we still observe their dominance on the bigger clusters. Therefore, it’s better to remove it. This, together with other modifications are the basis of SCpubr::do_VlnPlot(). This is how the default plot looks like: SCpubr::do_VlnPlot(sample = sample, features = &quot;nCount_RNA&quot;) Figure 8.3: SCpubr’s violin plot. In addition to removing the dots, a boxplot is added to each violin shape, to get a better sense of the quantiles of the distribution. This effect can be removed by using plot_boxplot = FALSE. Also, legend is by default removed, as the groups are being displayed already in the X axis. 8.1 Violin plots as a means of QC For QC analyses, users might want to also add some other features such as a line indicating where to put the cutoff. This can be achieved by using y_cut parameter. Currently, only one value per plot for y_cut can be used. SCpubr::do_VlnPlot(sample = sample, features = &quot;nCount_RNA&quot;, y_cut = 30000) Figure 8.4: SCpubr’s violin plot with horizontal line. When multiple features are queried, the user can set up different horizontal lines parsing them as a vector to y_cut. Also, the same can be achieved for the individual plot titles by using the individual.titles parameter. The only restriction, is that the vector has to be of the same length as the number of features. If for a particular plot, we do not want to modify anything, use NA instead. SCpubr::do_VlnPlot(sample = sample, features = c(&quot;nCount_RNA&quot;, &quot;nFeature_RNA&quot;), y_cut = c(NA, 5000), individual.titles = c(&quot;UMIs&quot;, NA)) Figure 8.5: SCpubr’s violin plot with multiple features. "],["dot-plots.html", "Chapter 9 Dot plots 9.1 Querying multiple features at once. 9.2 Clustering the identities. 9.3 Inverting the axes.", " Chapter 9 Dot plots Dot plots are a very nice data representation technique. It involves the use of two scales. One scale is color-based while the second one is size-based. In the context of Seurat::DotPlot(), these scales are pre-defined to contain the average expression values on the color scale and the percentage of cells within the group expressing the feature on the size, increasing it as this percentage grows bigger. It is heavily implied that the features need to be genes, otherwise the color scale will be lost. This is the output from Seurat: p1 &lt;- Seurat::DotPlot(sample, features = &quot;CD14&quot;) p2 &lt;- Seurat::DotPlot(sample, features = &quot;nCount_RNA&quot;) p1 | p2 Figure 9.1: Seurat DotPlot As can be seen, if we try to plot other type of variables, the resulting plot will not contain a color scale. SCpubr::do_DimPlot() focuses on enhancing the overall appearance of the plots. Implementation using other types of features is not currently supported. This is how it looks using SCpubr::do_DimPlot(): p1 &lt;- SCpubr::do_DotPlot(sample = sample, features = &quot;CD14&quot;) p2 &lt;- SCpubr::do_DotPlot(sample = sample, features = &quot;nFeature_RNA&quot;) p1 | p2 Figure 9.2: SCpubr DotPlot 9.1 Querying multiple features at once. The true power of this data visualization relies on querying multiple genes at once. Let’s query the ones described in this Seurat vignette: genes &lt;- c(&quot;IL7R&quot;, &quot;CCR7&quot;, &quot;CD14&quot;, &quot;LYZ&quot;, &quot;S100A4&quot;, &quot;MS4A1&quot;, &quot;CD8A&quot;, &quot;FCGR3A&quot;, &quot;MS4A7&quot;, &quot;GNLY&quot;, &quot;NKG7&quot;, &quot;FCER1A&quot;, &quot;CST3&quot;, &quot;PPBP&quot;) p1 &lt;- SCpubr::do_DotPlot(sample = sample, features = genes) p1 Figure 9.3: SCpubr DotPlot using multiple genes Here, we can clearly distinguish which clusters are highly enriched in which given genes. This proves to be a very interesting way to query for cluster identities. It is highly dependent, though, on the accuracy of the selected genes for the queried dataset. If we actually provide the list of genes as a named list, we can facet the plot in the different list of genes provided: genes &lt;- list(&quot;Naive CD4+ T&quot; = c(&quot;IL7R&quot;, &quot;CCR7&quot;), &quot;CD14+ Mono&quot; = c(&quot;CD14&quot;, &quot;LYZ&quot;), &quot;Memory CD4+&quot; = c(&quot;S100A4&quot;), &quot;B&quot; = c(&quot;MS4A1&quot;), &quot;CD8+ T&quot; = c(&quot;CD8A&quot;), &quot;FCGR3A+ Mono&quot; = c(&quot;FCGR3A&quot;, &quot;MS4A7&quot;), &quot;NK&quot; = c(&quot;GNLY&quot;, &quot;NKG7&quot;), &quot;DC&quot; = c(&quot;FCER1A&quot;, &quot;CST3&quot;), &quot;Platelet&quot; = c(&quot;PPBP&quot;)) p1 &lt;- SCpubr::do_DotPlot(sample = sample, features = genes) p1 Figure 9.4: SCpubr DotPlot using multiple genes 9.2 Clustering the identities. One really cool feature from Seurat::DotPlot() is that it lets you cluster the identities in the Y axis depending on how similar they are between them across the values on the X axis. This is achieved by using cluster.idents = TRUE, parameter also implemented in SCpubr::do_DotPlot(): genes &lt;- list(&quot;Naive CD4+ T&quot; = c(&quot;IL7R&quot;, &quot;CCR7&quot;), &quot;CD14+ Mono&quot; = c(&quot;CD14&quot;, &quot;LYZ&quot;), &quot;Memory CD4+&quot; = c(&quot;S100A4&quot;), &quot;B&quot; = c(&quot;MS4A1&quot;), &quot;CD8+ T&quot; = c(&quot;CD8A&quot;), &quot;FCGR3A+ Mono&quot; = c(&quot;FCGR3A&quot;, &quot;MS4A7&quot;), &quot;NK&quot; = c(&quot;GNLY&quot;, &quot;NKG7&quot;), &quot;DC&quot; = c(&quot;FCER1A&quot;, &quot;CST3&quot;), &quot;Platelet&quot; = c(&quot;PPBP&quot;)) p1 &lt;- SCpubr::do_DotPlot(sample = sample, features = genes, plot.title = &quot;Not clustered&quot;) p2 &lt;- SCpubr::do_DotPlot(sample = sample, features = genes, cluster.idents = TRUE, plot.title = &quot;Clustered&quot;) p1 / p2 Figure 9.5: SCpubr DotPlot using multiple genes and clustering the identities 9.3 Inverting the axes. In SCpubr::do_DotPlot(), we can also invert the axes, so that the groups are in the X axis and the genes in the Y axis. This is achieved by using flip = TRUE. Note, however, that this does not work when using a named list of genes as input, as it completelyl distort the way facets are computed. Given this, this combination of parameters is currently blocked by SCpubr. genes &lt;- c(&quot;IL7R&quot;, &quot;CCR7&quot;, &quot;CD14&quot;, &quot;LYZ&quot;, &quot;S100A4&quot;, &quot;MS4A1&quot;, &quot;CD8A&quot;, &quot;FCGR3A&quot;, &quot;MS4A7&quot;, &quot;GNLY&quot;, &quot;NKG7&quot;, &quot;FCER1A&quot;, &quot;CST3&quot;, &quot;PPBP&quot;) p1 &lt;- SCpubr::do_DotPlot(sample = sample, features = genes, plot.title = &quot;Not clustered&quot;, flip = T) p2 &lt;- SCpubr::do_DotPlot(sample = sample, features = genes, cluster.idents = TRUE, plot.title = &quot;Clustered&quot;, flip = T) p1 | p2 Figure 9.6: SCpubr DotPlot using multiple genes and clustering the identities flipping axes "],["bar-plots.html", "Chapter 10 Bar plots 10.1 Introducing a second variable to group the feature by 10.2 Reordering columns based on a single entity 10.3 Adding custom color scales.", " Chapter 10 Bar plots Bar plots are another well known data representation. They are a very handy resource to plot summary statistics for the QC part of any single-cell analysis. Consequently, they are part of SCpubr, available on SCpubr::do_BarPlot(). Let’s say we are interested into plotting the different number of cells in each cluster. p1 &lt;- SCpubr::do_BarPlot(sample, feature = &quot;seurat_clusters&quot;, legend = F, plot.title = &quot;Number of cells per cluster&quot;) p2 &lt;- SCpubr::do_BarPlot(sample, feature = &quot;seurat_clusters&quot;, legend = F, plot.title = &quot;Number of cells per cluster&quot;, horizontal = T) p1 | p2 Figure 10.1: SCpubr Bar plots, plotting single variables Using SCpubr::do_BarPlot() with only features yields a simple bar plot which is ordered by descending value. We can also set up the direction of the bars with horizontal = TRUE/FALSE, which by default is set to be vertical There are some underlying assumptions that are being taken to generate these plots: The values in features need to be metadata variables, stored in object@meta.data. This a design choice, as data need to be grouped using dplyr and tidyr. This will also later apply to values provided to group.by. The feature provided need to have a clear and rather small number of groups. A good estimate on how to assess this is by querying the feature with table, as in: table(sample@meta.data[, feature]) Focusing on the last point, this would happen if we were to choose a feature with a high number of unique values: p &lt;- SCpubr::do_BarPlot(sample, feature = &quot;nCount_RNA&quot;, legend = F, plot.title = &quot;Number of UMIs?&quot;, horizontal = F) p Figure 10.2: SCpubr Bar plots, choosing the wrong variable This happens, precisely, because of the high amount of unique values for nCount_RNA. These type of continuous values is best suited for other data visualizations like a histogram. 10.1 Introducing a second variable to group the feature by Let’s expand on the previous example on the number of cells per cluster. What if we were interested not only on that, but we would like to profile how many cells from each cluster are present in each of the unique samples present in the Seurat object? For this, we need to provide SCpubr::do_BarPlot() with a second parameter, group.by, that tackles how we want the feature to be grouped: # We only have one value in orig.ident. Let&#39;s modify it so that it resembles a multi-sample Seurat object. sample$modified_orig.ident &lt;- sample(c(&quot;Sample_A&quot;, &quot;Sample_B&quot;, &quot;Sample_C&quot;), ncol(sample), replace = T, prob = c(0.2, 0.7, 0.1)) p1 &lt;- SCpubr::do_BarPlot(sample, feature = &quot;modified_orig.ident&quot;, plot.title = &quot;Number of cells per sample&quot;, position = &quot;stack&quot;, legend = T, horizontal = F) #&gt; Warning in SCpubr::do_BarPlot(sample, feature = &quot;modified_orig.ident&quot;, #&gt; plot.title = &quot;Number of cells per sample&quot;, : Recommended settings without using #&gt; group.by is to set legend to FALSE. p2 &lt;- SCpubr::do_BarPlot(sample, feature = &quot;modified_orig.ident&quot;, group.by = &quot;seurat_clusters&quot;, plot.title = &quot;Number of cells per cluster and sample&quot;, position = &quot;stack&quot;, legend = T, horizontal = F) #&gt; Warning in SCpubr::do_BarPlot(sample, feature = &quot;modified_orig.ident&quot;, group.by #&gt; = &quot;seurat_clusters&quot;, : Recommended settings when using group.by is to set #&gt; position to &#39;fill&#39;. p1 | p2 Figure 10.3: SCpubr Bar plots, introducing a variable to group values by As we can see, this nicely yields as many number of bars as unique values in the feature, and this bars are segmented by as many times as unique values in group.by. At first, this is hard to grasp, but it helps thinking of these two parameters, when used together, as: feature: What I want to show as different bars. group.by: Secondary variable on which the bars generated by feature can be further subdivided. Another interesting parameter introduced in the last example is position. Position can be either stack or fill. The difference between them is that position = \"stack\" will yield the total number of cells for each of the unique values in feature, while position = \"fill\" will bring all bars to the same height and will split each bar into the proportions within each bar of the different groups (only one if group.by = NULL and as many groups if group.by is used). Therefore, it becomes highly recommended to use position = \"stack\" when group.by is not used and position = \"fill\" otherwise. This is also warned by the package. If you want to silence the warnings, use verbose = FALSE. # We are going to use the previously generated sample assignment. p1 &lt;- SCpubr::do_BarPlot(sample, feature = &quot;modified_orig.ident&quot;, plot.title = &quot;Without group.by - position = stack&quot;, position = &quot;stack&quot;, legend = T, horizontal = F) #&gt; Warning in SCpubr::do_BarPlot(sample, feature = &quot;modified_orig.ident&quot;, #&gt; plot.title = &quot;Without group.by - position = stack&quot;, : Recommended settings #&gt; without using group.by is to set legend to FALSE. p2 &lt;- SCpubr::do_BarPlot(sample, feature = &quot;modified_orig.ident&quot;, plot.title = &quot;Without group.by - position = fill&quot;, position = &quot;fill&quot;, legend = T, horizontal = F) #&gt; Warning in SCpubr::do_BarPlot(sample, feature = &quot;modified_orig.ident&quot;, #&gt; plot.title = &quot;Without group.by - position = fill&quot;, : Recommended settings #&gt; without using group.by is to set legend to FALSE. #&gt; Warning in SCpubr::do_BarPlot(sample, feature = &quot;modified_orig.ident&quot;, #&gt; plot.title = &quot;Without group.by - position = fill&quot;, : Recommended settings #&gt; without using group.by is to set position to &#39;stack&#39;. p3 &lt;- SCpubr::do_BarPlot(sample, feature = &quot;modified_orig.ident&quot;, group.by = &quot;seurat_clusters&quot;, plot.title = &quot;With group.by - position = stack&quot;, position = &quot;stack&quot;, legend = T, horizontal = F) #&gt; Warning in SCpubr::do_BarPlot(sample, feature = &quot;modified_orig.ident&quot;, group.by #&gt; = &quot;seurat_clusters&quot;, : Recommended settings when using group.by is to set #&gt; position to &#39;fill&#39;. p4 &lt;- SCpubr::do_BarPlot(sample, feature = &quot;modified_orig.ident&quot;, group.by = &quot;seurat_clusters&quot;, plot.title = &quot;With group.by - position = fill&quot;, position = &quot;fill&quot;, legend = T, horizontal = F) p &lt;- (p1 | p2) / (p3 | p4) p Figure 10.4: SCpubr Bar plots, difference between position 10.2 Reordering columns based on a single entity One advanced use of bar plots, but a very useful one is to reorder the columns based on a single entity in a descending order. This works only when group.by is set up and best when position = \"fill\". For instance, imagine the scenario in which we are heavily interested in cluster 1, and want to reorder the columns based on it. This is achieved by providing order.by parameter to SCpubr::do_BarPlot(). The value in order.by has to be necessary one of the unique values in group.by. Therefore, as a best practice, one would want to generate the bar plots without using order.by and then decide. Let’s also, for the sake of this example, modify the proportions of cluster 1 so that it becomes really evident. This is how it looks: # Modify proportions. sample$modified_seurat_clusters &lt;- as.character(sample$seurat_clusters) sample$modified_seurat_clusters[sample$modified_orig.ident == &quot;Sample_A&quot; &amp; sample$modified_seurat_clusters %in% c(&quot;0&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;)] &lt;- &quot;1&quot; p1 &lt;- SCpubr::do_BarPlot(sample, feature = &quot;modified_orig.ident&quot;, group.by = &quot;modified_seurat_clusters&quot;, plot.title = &quot;Number of cells per sample&quot;, order.by = &quot;1&quot;, position = &quot;stack&quot;, legend = T, horizontal = F) #&gt; Warning in SCpubr::do_BarPlot(sample, feature = &quot;modified_orig.ident&quot;, group.by #&gt; = &quot;modified_seurat_clusters&quot;, : Recommended settings when using group.by is to #&gt; set position to &#39;fill&#39;. p2 &lt;- SCpubr::do_BarPlot(sample, feature = &quot;modified_orig.ident&quot;, group.by = &quot;modified_seurat_clusters&quot;, plot.title = &quot;Number of cells per cluster and sample&quot;, order.by = &quot;1&quot;, position = &quot;fill&quot;, legend = T, horizontal = F) p1 | p2 Figure 10.5: SCpubr Bar plots, reordering the colums using order.by 10.3 Adding custom color scales. If necesary, the colors of the plots can be easily changed using the colors.use parameter, which requires a named vector containing the HEX codes of the colors to show and the names of the unique values that are being used as color groups. Here is one example: # Create a color scale for the unique values in seurat clusters. colors &lt;- c(&quot;0&quot; = &quot;#001219&quot;, &quot;1&quot; = &quot;#005f73&quot;, &quot;2&quot; = &quot;#0a9396&quot;, &quot;3&quot; = &quot;#94d2bd&quot;, &quot;4&quot; = &quot;#e9d8a6&quot;, &quot;5&quot; = &quot;#ee9b00&quot;, &quot;6&quot; = &quot;#ca6702&quot;, &quot;7&quot; = &quot;#bb3e03&quot;, &quot;8&quot; = &quot;#ae2012&quot;, &quot;9&quot; = &quot;#9b2226&quot;) p1 &lt;- SCpubr::do_BarPlot(sample, feature = &quot;seurat_clusters&quot;, legend = F, plot.title = &quot;Number of cells per cluster&quot;, horizontal = T, colors.use = colors) p2 &lt;- SCpubr::do_BarPlot(sample, feature = &quot;modified_orig.ident&quot;, group.by = &quot;seurat_clusters&quot;, plot.title = &quot;With group.by - position = fill&quot;, position = &quot;fill&quot;, legend = T, horizontal = F, colors.use = colors) p1 | p2 Figure 10.6: SCpubr, modifying colors "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page’s new location, or use the table of contents to find the page you are looking for. "]]
